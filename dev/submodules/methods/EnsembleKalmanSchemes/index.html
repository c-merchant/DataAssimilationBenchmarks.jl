<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EnsembleKalmanSchemes · DataAssimilationBenchmarks</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">DataAssimilationBenchmarks</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">DataAssimilationBenchmarks</span><ul><li><a class="tocitem" href="../../../home/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../../home/Getting Started/">Getting Started</a></li><li><a class="tocitem" href="../../../home/DataAssimilationBenchmarks/">Global Types</a></li></ul></li><li><span class="tocitem">Submodules</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Models</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../models/L96/">L96</a></li><li><a class="tocitem" href="../../models/IEEE39bus/">IEEE39bus</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../DeSolvers/">DeSolvers</a></li><li class="is-active"><a class="tocitem" href>EnsembleKalmanSchemes</a><ul class="internal"><li><a class="tocitem" href="#API-for-data-assimilation-solvers"><span>API for data assimilation solvers</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Experiments</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../experiments/GenerateTimeSeries/">GenerateTimeSeries</a></li><li><a class="tocitem" href="../../experiments/FilterExps/">FilterExps</a></li><li><a class="tocitem" href="../../experiments/SmootherExps/">SmootherExps</a></li><li><a class="tocitem" href="../../experiments/SingleExperimentDriver/">SingleExperimentDriver</a></li><li><a class="tocitem" href="../../experiments/Slurm/">Slurm</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../analysis/ProcessExperimentData/">ProcessExperimentData</a></li><li><a class="tocitem" href="../../analysis/PlotExperimentData/">PlotExperimentData</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Submodules</a></li><li><a class="is-disabled">Methods</a></li><li class="is-active"><a href>EnsembleKalmanSchemes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>EnsembleKalmanSchemes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/master/docs/src/submodules/methods/EnsembleKalmanSchemes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ensemble-Kalman-Schemes"><a class="docs-heading-anchor" href="#Ensemble-Kalman-Schemes">Ensemble Kalman Schemes</a><a id="Ensemble-Kalman-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-Kalman-Schemes" title="Permalink"></a></h1><h2 id="API-for-data-assimilation-solvers"><a class="docs-heading-anchor" href="#API-for-data-assimilation-solvers">API for data assimilation solvers</a><a id="API-for-data-assimilation-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#API-for-data-assimilation-solvers" title="Permalink"></a></h2><p>Different filter and smoothing schemes are run through the routines including</p><pre><code class="language- hljs">ensemble_filter(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},
                         obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})

ls_smoother_classic(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},
                             obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})

ls_smoother_single_iteration(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},
                             obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})


ls_smoother_gauss_newton(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},
                             obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any};
                             ϵ::Float64=0.0001, tol::Float64=0.001, max_iter::Int64=10)

# type union for multiple dispatch over specific types of covariance matrices
CovM = Union{UniformScaling{Float64}, Diagonal{Float64}, Symmetric{Float64}}

analysis   -- string of the DA scheme string name, given to the transform sub-routine in
              methods
ens        -- ensemble matrix defined by the array with columns given by the replicates of
              the model state
obs        -- observation vector for the current analysis in ensemble_filter / array with
              columns given by the observation vectors for the ordered sequence of analysis
							times in the current smoothing window
obs_cov    -- observation error covariance matrix, must be positive definite of type CovM
state_infl -- multiplicative covariance inflation factor for the state variable covariance
              matrix, set to one this is the standard Kalman-like update
kwargs     -- keyword arguments for parameter estimation or other functionality, including
              integration parameters for the state model in smoothing schemes</code></pre><p>The type of analysis to be passed to the transform step is specified with the <code>analysis</code> string.  Observations for the filter schemes correspond to information available at a single analysis time while the ls (lag-shift) smoothers require an array of observations corresponding to all analysis times within the DAW.  Observation covariances should be typed according to the type union above for efficiency.  The state_infl is a required tuneable parameter for multiplicative covariance inflation.   Extended parameter state covariance inflation can be specified in <code>kwargs</code>.  These outer loops will pass the required values to the <code>transform</code>  function that generates the ensemble transform for conditioning on observations.  Different outer-loop  schemes can be built around the <code>transform</code> function alone in order to use validated ensemble transform  schemes.  Utility scripts to generate observation operators, analyze ensemble statistics, etc, are included in the EnsembleKalmanSchemes.jl sub-module.  See the experiments directory discussed below for example usage.</p><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator-Tuple{Matrix{Float64}, Int64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator-Tuple{Matrix{Float64}, Int64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alternating_obs_operator(ens::Array{Float64,2}, obs_dim::Int64, 
                         kwargs::Dict{String,Any})</code></pre><p>Observation of alternating state vector components, possibly nonlinear transformation. This selects components to observe based on the observation dimension and if parameter estimation is being performed.  Parameters are always unobservable, and even states will be removed from the state vector until the observation dimension is appropriate.  Nonlinear observations are optional, as described for the Lorenz-96 model by Asch, Bocquet, Nodet pg. 181.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analyze_ens(ens::ArView, truth::Vector{Float64})</code></pre><p>Computes the ensemble RMSE as compared with truth twin, and the ensemble spread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analyze_ens_para(ens::ArView, truth::Vector{Float64})</code></pre><p>Computes the ensemble RMSE as compared with truth twin, and the ensemble spread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!-Union{Tuple{T1}, Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, T1}} where T1&lt;:Union{Tuple{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}}, Tuple{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Vector{Float64}, Matrix{Float64}}, Matrix{Float64}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!-Union{Tuple{T1}, Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, T1}} where T1&lt;:Union{Tuple{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}}, Tuple{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Vector{Float64}, Matrix{Float64}}, Matrix{Float64}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ens_update!(ens::ArView, transform::T1) where {T1 &lt;: TransM}</code></pre><p>Updates ensemble by right-transform method. In the case where this follows the stochastic EnKF as in Carrassi et al. 2018, this simply performs right mutliplication.  All other cases use the 3-tuple including the right transform for the anomalies, the weights for the mean and the random, mean-preserving orthogonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L966-L974">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ensemble_filter(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},  
                obs_cov::CovM, s_infl::Float64, kwargs::Dict{String,Any})</code></pre><p>General filter analysis step, wrapping the transform / update, and inflation steps. Optional keyword argument includes state_dim for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L998-L1006">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!-Tuple{Matrix{Float64}, Float64, Int64, Int64}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!-Tuple{Matrix{Float64}, Float64, Int64, Int64}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inflate_param!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, 
               state_dim::Int64)</code></pre><p>Parameter variable multiplicative covariance inflation. State variables are assumed to be in the leading rows, while extended state, parameter variables are after. Multiplicative inflation is performed only in the trailing components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!-Tuple{Matrix{Float64}, Float64, Int64, Int64}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!-Tuple{Matrix{Float64}, Float64, Int64, Int64}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inflate_state!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, 
               state_dim::Int64)</code></pre><p>Dynamic state variable multiplicative covariance inflation.  State variables are assumed to be in the leading rows, while extended state variables, parameter variables are after. Multiplicative inflation is performed only in the leading components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L172-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ls_smoother_classic(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},  
                    obs_cov::CovM, s_infl::Float64, kwargs::Dict{String,Any})</code></pre><p>Lag-shift ensemble kalman smoother analysis step, classical version. Classic enks uses the last filtered state for the forecast, different from the  iterative schemes which use the once or multiple-times re-analized posterior for the initial condition for the forecast of the states to the next shift.</p><p>Optional argument includes state dimension for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L1039-L1051">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ls_smoother_gauss_newton(analysis::String, ens::Array{Float64,2},                   
                         obs::Array{Float64,2}, obs_cov::CovM, s_infl::Float64,
                         kwargs::Dict{String,Any}; ϵ::Float64=0.0001,
                         tol::Float64=0.001, max_iter::Int64=5)</code></pre><p>Lag-shift Gauss-Newton IEnKS analysis step, algorithm 4, Bocquet &amp; Sakov 2014 ienks uses the final re-analyzed posterior initial state for the forecast,  which is pushed forward in time from the initial conidtion to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L1449-L1461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ls_smoother_single_iteration(analysis::String, ens::Array{Float64,2},       
                             obs::Array{Float64,2}, obs_cov::CovM,
                             s_infl::Float64, kwargs::Dict{String,Any})</code></pre><p>Lag-shift ensemble kalman smoother analysis step, single iteration version. Single-iteration enks uses the final re-analyzed posterior initial state for the forecast, which is pushed forward in time to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L1164-L1175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth-Tuple{Int64}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth-Tuple{Int64}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_orth(N_ens::Int64)</code></pre><p>This generates a random. mean preserving, orthogonal matrix as in Sakov &amp; Oke 2008.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root-Tuple{T} where T&lt;:Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root-Tuple{T} where T&lt;:Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_root(M::T) where {T &lt;: CovM}</code></pre><p>Auxiliary function for computing the square roots of multiple types of covariance matrices, with the subroutines defined according to the sub-type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L216-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv-Tuple{T} where T&lt;:Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv-Tuple{T} where T&lt;:Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_root_inv(M::T) where {T &lt;: CovM}</code></pre><p>Auxiliary function for computing the square root inverse of multiple types of covariance matrices, with the subroutines defined according to the sub-type. This will optionally return a computation of the inverse and the square root itself all as a byproduct of the singular value decomposition computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L237-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},        
       obs_cov::CovM, kwargs::Dict{String,Any}; conditioning::ConM=1000.0I, 
       m_err::Array{Float64,2}=(1.0 ./ zeros(1,1)),
       tol::Float64 = 0.0001,
       j_max::Int64=40,
       Q::CovM=1.0I)</code></pre><p>Computes transform and related values for various flavors of ensemble Kalman schemes. Serves as an auxilliary function for EnKF, ETKF(-N), EnKS, ETKS(-N), IEnKS(-N), where &quot;analysis&quot; is a string which determines the type of transform update.  The observation error covariance should be of UniformScaling, Diagonal or Symmetric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks.jl/blob/18d3a43a3548946385539daa2077dde727102ee9/src/methods/EnsembleKalmanSchemes.jl#L304-L316">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DeSolvers/">« DeSolvers</a><a class="docs-footer-nextpage" href="../../experiments/GenerateTimeSeries/">GenerateTimeSeries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.17 on <span class="colophon-date" title="Tuesday 10 May 2022 03:27">Tuesday 10 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
