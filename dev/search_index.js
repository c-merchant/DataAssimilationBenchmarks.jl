var documenterSearchIndex = {"docs":
[{"location":"submodules/methods/EnsembleKalmanSchemes/#Ensemble-Kalman-Schemes","page":"EnsembleKalmanSchemes","title":"Ensemble Kalman Schemes","text":"","category":"section"},{"location":"submodules/methods/EnsembleKalmanSchemes/#API-for-data-assimilation-solvers","page":"EnsembleKalmanSchemes","title":"API for data assimilation solvers","text":"","category":"section"},{"location":"submodules/methods/EnsembleKalmanSchemes/","page":"EnsembleKalmanSchemes","title":"EnsembleKalmanSchemes","text":"Different filter and smoothing schemes are run through the routines including","category":"page"},{"location":"submodules/methods/EnsembleKalmanSchemes/","page":"EnsembleKalmanSchemes","title":"EnsembleKalmanSchemes","text":"ensemble_filter(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},\n                         obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})\n\nls_smoother_classic(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},\n                             obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})\n\nls_smoother_single_iteration(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},\n                             obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})\n\n\nls_smoother_gauss_newton(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},\n                             obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any};\n                             Ïµ::Float64=0.0001, tol::Float64=0.001, max_iter::Int64=10)\n\n# type union for multiple dispatch over specific types of covariance matrices\nCovM = Union{UniformScaling{Float64}, Diagonal{Float64}, Symmetric{Float64}}\n\nanalysis   -- string of the DA scheme string name, given to the transform sub-routine in\n              methods\nens        -- ensemble matrix defined by the array with columns given by the replicates of\n              the model state\nobs        -- observation vector for the current analysis in ensemble_filter / array with\n              columns given by the observation vectors for the ordered sequence of analysis\n\t\t\t\t\t\t\ttimes in the current smoothing window\nobs_cov    -- observation error covariance matrix, must be positive definite of type CovM\nstate_infl -- multiplicative covariance inflation factor for the state variable covariance\n              matrix, set to one this is the standard Kalman-like update\nkwargs     -- keyword arguments for parameter estimation or other functionality, including\n              integration parameters for the state model in smoothing schemes","category":"page"},{"location":"submodules/methods/EnsembleKalmanSchemes/","page":"EnsembleKalmanSchemes","title":"EnsembleKalmanSchemes","text":"The type of analysis to be passed to the transform step is specified with the analysis string.  Observations for the filter schemes correspond to information available at a single analysis time while the ls (lag-shift) smoothers require an array of observations corresponding to all analysis times within the DAW.  Observation covariances should be typed according to the type union above for efficiency.  The state_infl is a required tuneable parameter for multiplicative covariance inflation.   Extended parameter state covariance inflation can be specified in kwargs.  These outer loops will pass the required values to the transform  function that generates the ensemble transform for conditioning on observations.  Different outer-loop  schemes can be built around the transform function alone in order to use validated ensemble transform  schemes.  Utility scripts to generate observation operators, analyze ensemble statistics, etc, are included in the EnsembleKalmanSchemes.jl sub-module.  See the experiments directory discussed below for example usage.","category":"page"},{"location":"submodules/methods/EnsembleKalmanSchemes/#Docstrings","page":"EnsembleKalmanSchemes","title":"Docstrings","text":"","category":"section"},{"location":"submodules/methods/EnsembleKalmanSchemes/","page":"EnsembleKalmanSchemes","title":"EnsembleKalmanSchemes","text":"Modules = [DataAssimilationBenchmarks.EnsembleKalmanSchemes]","category":"page"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator-Tuple{Matrix{Float64}, Int64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator","text":"alternating_obs_operator(ens::Array{Float64,2}, obs_dim::Int64, \n                         kwargs::Dict{String,Any})\n\nObservation of alternating state vector components, possibly nonlinear transformation. This selects components to observe based on the observation dimension and if parameter estimation is being performed.  Parameters are always unobservable, and even states will be removed from the state vector until the observation dimension is appropriate.  Nonlinear observations are optional, as described for the Lorenz-96 model by Asch, Bocquet, Nodet pg. 181.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens","text":"analyze_ens(ens::ArView, truth::Vector{Float64})\n\nComputes the ensemble RMSE as compared with truth twin, and the ensemble spread.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para","text":"analyze_ens_para(ens::ArView, truth::Vector{Float64})\n\nComputes the ensemble RMSE as compared with truth twin, and the ensemble spread.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!-Union{Tuple{T1}, Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, T1}} where T1<:Union{Tuple{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}}, Tuple{LinearAlgebra.Symmetric{Float64, Matrix{Float64}}, Vector{Float64}, Matrix{Float64}}, Matrix{Float64}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!","text":"ens_update!(ens::ArView, transform::T1) where {T1 <: TransM}\n\nUpdates ensemble by right-transform method. In the case where this follows the stochastic EnKF as in Carrassi et al. 2018, this simply performs right mutliplication.  All other cases use the 3-tuple including the right transform for the anomalies, the weights for the mean and the random, mean-preserving orthogonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter","text":"ensemble_filter(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},  \n                obs_cov::CovM, s_infl::Float64, kwargs::Dict{String,Any})\n\nGeneral filter analysis step, wrapping the transform / update, and inflation steps. Optional keyword argument includes state_dim for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!-Tuple{Matrix{Float64}, Float64, Int64, Int64}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!","text":"inflate_param!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, \n               state_dim::Int64)\n\nParameter variable multiplicative covariance inflation. State variables are assumed to be in the leading rows, while extended state, parameter variables are after. Multiplicative inflation is performed only in the trailing components.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!-Tuple{Matrix{Float64}, Float64, Int64, Int64}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!","text":"inflate_state!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, \n               state_dim::Int64)\n\nDynamic state variable multiplicative covariance inflation.  State variables are assumed to be in the leading rows, while extended state variables, parameter variables are after. Multiplicative inflation is performed only in the leading components.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic","text":"ls_smoother_classic(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},  \n                    obs_cov::CovM, s_infl::Float64, kwargs::Dict{String,Any})\n\nLag-shift ensemble kalman smoother analysis step, classical version. Classic enks uses the last filtered state for the forecast, different from the  iterative schemes which use the once or multiple-times re-analized posterior for the initial condition for the forecast of the states to the next shift.\n\nOptional argument includes state dimension for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton","text":"ls_smoother_gauss_newton(analysis::String, ens::Array{Float64,2},                   \n                         obs::Array{Float64,2}, obs_cov::CovM, s_infl::Float64,\n                         kwargs::Dict{String,Any}; Ïµ::Float64=0.0001,\n                         tol::Float64=0.001, max_iter::Int64=5)\n\nLag-shift Gauss-Newton IEnKS analysis step, algorithm 4, Bocquet & Sakov 2014 ienks uses the final re-analyzed posterior initial state for the forecast,  which is pushed forward in time from the initial conidtion to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration","text":"ls_smoother_single_iteration(analysis::String, ens::Array{Float64,2},       \n                             obs::Array{Float64,2}, obs_cov::CovM,\n                             s_infl::Float64, kwargs::Dict{String,Any})\n\nLag-shift ensemble kalman smoother analysis step, single iteration version. Single-iteration enks uses the final re-analyzed posterior initial state for the forecast, which is pushed forward in time to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth-Tuple{Int64}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth","text":"rand_orth(N_ens::Int64)\n\nThis generates a random. mean preserving, orthogonal matrix as in Sakov & Oke 2008.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root-Tuple{T} where T<:Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root","text":"square_root(M::T) where {T <: CovM}\n\nAuxiliary function for computing the square roots of multiple types of covariance matrices, with the subroutines defined according to the sub-type.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv-Tuple{T} where T<:Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv","text":"square_root_inv(M::T) where {T <: CovM}\n\nAuxiliary function for computing the square root inverse of multiple types of covariance matrices, with the subroutines defined according to the sub-type. This will optionally return a computation of the inverse and the square root itself all as a byproduct of the singular value decomposition computation.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{LinearAlgebra.UniformScaling{Float64}, LinearAlgebra.Diagonal{Float64, V} where V<:AbstractVector{Float64}, LinearAlgebra.Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform","text":"transform(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},        \n       obs_cov::CovM, kwargs::Dict{String,Any}; conditioning::ConM=1000.0I, \n       m_err::Array{Float64,2}=(1.0 ./ zeros(1,1)),\n       tol::Float64 = 0.0001,\n       j_max::Int64=40,\n       Q::CovM=1.0I)\n\nComputes transform and related values for various flavors of ensemble Kalman schemes. Serves as an auxilliary function for EnKF, ETKF(-N), EnKS, ETKS(-N), IEnKS(-N), where \"analysis\" is a string which determines the type of transform update.  The observation error covariance should be of UniformScaling, Diagonal or Symmetric type.\n\n\n\n\n\n","category":"method"},{"location":"home/DataAssimilationBenchmarks/#Global-Types","page":"Global Types","title":"Global Types","text":"","category":"section"},{"location":"home/DataAssimilationBenchmarks/","page":"Global Types","title":"Global Types","text":"The following types are declared for optimizing numerical routines and for using multiple dispatch of functions with different specified input forms.","category":"page"},{"location":"home/DataAssimilationBenchmarks/","page":"Global Types","title":"Global Types","text":"Modules = [DataAssimilationBenchmarks]","category":"page"},{"location":"home/DataAssimilationBenchmarks/#DataAssimilationBenchmarks.ArView","page":"Global Types","title":"DataAssimilationBenchmarks.ArView","text":"ArView = Union{Array{Float64, 2}, SubArray{Float64, 2}}\n\nType union of arrays and views of arrays for use within ensemble conditioning operations, integration schemes and other array operations.\n\n\n\n\n\n","category":"type"},{"location":"home/DataAssimilationBenchmarks/#DataAssimilationBenchmarks.ConM","page":"Global Types","title":"DataAssimilationBenchmarks.ConM","text":"ConM = Union{UniformScaling{Float64}, Symmetric{Float64}}\n\nType union of conditioning matrix types, which are used for optimization routines in the transform method.\n\n\n\n\n\n","category":"type"},{"location":"home/DataAssimilationBenchmarks/#DataAssimilationBenchmarks.CovM","page":"Global Types","title":"DataAssimilationBenchmarks.CovM","text":"CovM = Union{UniformScaling{Float64}, Diagonal{Float64}, Symmetric{Float64}}\n\nType union of covariance matrix types, for optimized computation based on their special characteristics as symmetric, positive definite operators.\n\n\n\n\n\n","category":"type"},{"location":"home/DataAssimilationBenchmarks/#DataAssimilationBenchmarks.ParamDict","page":"Global Types","title":"DataAssimilationBenchmarks.ParamDict","text":"ParamDict = Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}\n\nDictionary for model parameters to be passed to derivative functions by name.  This allows one to pass both vector parameters (and scalars written as vectors), as well as matrix valued parameters such as diffusion arrays.\n\n\n\n\n\n","category":"type"},{"location":"home/DataAssimilationBenchmarks/#DataAssimilationBenchmarks.TransM","page":"Global Types","title":"DataAssimilationBenchmarks.TransM","text":"TransM = Union{Tuple{Symmetric{Float64, Array{Float64,2}}, Array{Float64,2},\n                     Array{Float64,2}},\n               Tuple{Symmetric{Float64, Array{Float64,2}},\n                     Array{Float64,1}, Array{Float64,2}},\n               Array{Float64,2}}\n\nType union of right ensemble transform types, including soley a transform, or a transform, weights and rotation package.\n\n\n\n\n\n","category":"type"},{"location":"home/DataAssimilationBenchmarks/#DataAssimilationBenchmarks.VecA","page":"Global Types","title":"DataAssimilationBenchmarks.VecA","text":"VecA = Union{Vector{Float64}, SubArray{Float64, 1}}\n\nType union of Vectors and SubArrays in order to pass columns of an ensemble maxtrix into integration schemes and related array operations.\n\n\n\n\n\n","category":"type"},{"location":"home/DataAssimilationBenchmarks/#DataAssimilationBenchmarks.ParamSample","page":"Global Types","title":"DataAssimilationBenchmarks.ParamSample","text":"ParamSample = Dict{String, Vector{UnitRange{Int64}}}\n\nDictionary containing key and index pairs to subset the state vector and then merge a statistical sample of parameters that govern the equations of motion with the ParamDict dx_params in parameter estimation problems.\n\n\n\n\n\n","category":"type"},{"location":"submodules/experiments/SingleExperimentDriver/#SingleExperimentDriver","page":"SingleExperimentDriver","title":"SingleExperimentDriver","text":"","category":"section"},{"location":"submodules/experiments/SingleExperimentDriver/#SingleExperimentDriver-API","page":"SingleExperimentDriver","title":"SingleExperimentDriver API","text":"","category":"section"},{"location":"submodules/experiments/SingleExperimentDriver/","page":"SingleExperimentDriver","title":"SingleExperimentDriver","text":"While the above filter experiments and smoother experiments configure twin experiments, run them and save the outputs, the SingleExperimentDriver.jl and ParallelExperimentDriver.jl can be used as wrappers to run generic model settings for debugging and validation, or to use built-in Julia parallelism to run a collection experiments over a parameter grid. The SingleExperimentDriver.jl is primarily for debugging purposes with tools like BenchmarkTools.jl and Debugger.jl, so that standard inputs can be run with the experiment called with macros.","category":"page"},{"location":"submodules/experiments/SingleExperimentDriver/#Docstrings","page":"SingleExperimentDriver","title":"Docstrings","text":"","category":"section"},{"location":"submodules/experiments/SingleExperimentDriver/","page":"SingleExperimentDriver","title":"SingleExperimentDriver","text":"Modules = [DataAssimilationBenchmarks.SingleExperimentDriver]","category":"page"},{"location":"submodules/experiments/SingleExperimentDriver/#DataAssimilationBenchmarks.SingleExperimentDriver.exps","page":"SingleExperimentDriver","title":"DataAssimilationBenchmarks.SingleExperimentDriver.exps","text":"exps[\"Experiment_name\"][\"Parameter_settings\"]\n\nThis dictionary contains standard inputs for experiments, written as named tuples and stored hierarchically by experiment type.  These standard inputs are used in the package for for debugging, testing, benchmarking and profiling. Parallel submission scripts are used for performance on servers.\n\n\n\n\n\n","category":"constant"},{"location":"submodules/experiments/FilterExps/#FilterExps","page":"FilterExps","title":"FilterExps","text":"","category":"section"},{"location":"submodules/experiments/FilterExps/#FilterExps-API","page":"FilterExps","title":"FilterExps API","text":"","category":"section"},{"location":"submodules/experiments/FilterExps/","page":"FilterExps","title":"FilterExps","text":"The FilterExps.jl sub-module configures twin experiments using stored time series data as generated above for  efficiency when using the same base-line time series to generate possibly different experiment configurations. Experiment configurations are generated by","category":"page"},{"location":"submodules/experiments/FilterExps/","page":"FilterExps","title":"FilterExps","text":"filter_state(args::Tuple{String,String,Int64,Int64,Float64,Int64,Float64,Int64,Float64})\ntime_series, method, seed, nanl, obs_un, obs_dim, Î³, N_ens, infl = args","category":"page"},{"location":"submodules/experiments/FilterExps/","page":"FilterExps","title":"FilterExps","text":"where time_series specifies the path to the .jld2 truth twin, method specifies the filter scheme, seed specifies the pseudo-random seed, nanl is the number of observation / analysis times to produce a posterior estimate for,  obs_un specifies the observation error standard deviation, assuming a uniform scaling observation error covariance, obs_dim specifies the dimension of the observation vector, Î³ specifies the level of the nonliearity in the alternating_obs_operator, N_ens specifies the ensemble size and infl specifies the (static) multiplicative inflation.","category":"page"},{"location":"submodules/experiments/FilterExps/","page":"FilterExps","title":"FilterExps","text":"Similar conventions follow for parameter estimation experiments","category":"page"},{"location":"submodules/experiments/FilterExps/","page":"FilterExps","title":"FilterExps","text":"filter_param(args::Tuple{String,String,Int64,Int64,Float64,Int64,\n                         Float64,Float64,Float64,Int64,Float64,Float64})\ntime_series, method, seed, nanl, obs_un, obs_dim,\nÎ³, param_err, param_wlk, N_ens, state_infl, param_infl = args","category":"page"},{"location":"submodules/experiments/FilterExps/","page":"FilterExps","title":"FilterExps","text":"with the exception of including the standard deviation, param_err, of the initial iid Gaussian draw of the parameter sample centered at the true value, the standard deviation, param_wlk, of the random walk applied to the parameter sample after each analysis and the multiplicative covariance inflation applied separately to the extended parameter states alone param_infl.","category":"page"},{"location":"submodules/experiments/FilterExps/#Docstrings","page":"FilterExps","title":"Docstrings","text":"","category":"section"},{"location":"submodules/experiments/FilterExps/","page":"FilterExps","title":"FilterExps","text":"Modules = [DataAssimilationBenchmarks.FilterExps]","category":"page"},{"location":"submodules/experiments/FilterExps/#DataAssimilationBenchmarks.FilterExps.filter_param-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :obs_un, :obs_dim, :Î³, :p_err, :p_wlk, :N_ens, :s_infl, :p_infl), <:Tuple{String, String, Int64, Int64, Float64, Int64, Float64, Float64, Float64, Int64, Float64, Float64}}}","page":"FilterExps","title":"DataAssimilationBenchmarks.FilterExps.filter_param","text":"filter_param((time_series::String, method::String, seed::Int64, nanl::Int64, \n              obs_un::Float64, obs_dim::Int64, Î³::Float64, p_err::Float64, p_wlk::Float64,\n              N_ens::Int64, s_infl::Float64, p_infl::Float64)::NamedTuple)\n\nFilter joint state-parameter estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments of the NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/FilterExps/#DataAssimilationBenchmarks.FilterExps.filter_state-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :obs_un, :obs_dim, :Î³, :N_ens, :s_infl), <:Tuple{String, String, Int64, Int64, Float64, Int64, Float64, Int64, Float64}}}","page":"FilterExps","title":"DataAssimilationBenchmarks.FilterExps.filter_state","text":"filter_state((time_series::String, method::String, seed::Int64, nanl::Int64,\n              obs_un::Float64, obs_dim::Int64, Î³::Float64, N_ens::Int64,\n              s_infl::Float64)::NamedTuple)\n\nFilter state estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size  etc. are specified in the arguments of the NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/SmootherExps/#SmootherExps","page":"SmootherExps","title":"SmootherExps","text":"","category":"section"},{"location":"submodules/experiments/SmootherExps/#SmootherExps-API","page":"SmootherExps","title":"SmootherExps API","text":"","category":"section"},{"location":"submodules/experiments/SmootherExps/","page":"SmootherExps","title":"SmootherExps","text":"The SmootherExps.jl sub-module configures twin experiments using stored time series data as generated above for  efficiency when using the same base-line time series to generate possibly different experiment configurations. Experiment configurations are generated by function calls as with the filter experiments, but with the additional options of how the outer-loop is configured with a classic, single-iteration or the fully iterative Gauss-Newton style smoother. The parameters lag and shift specify how the data assimilation windows are translated in over the observation and analysis times.  The mda parameter is only applicable to the single-iteration and Gauss-Newton style smoothers, utlizing sequential multiple data assimilation.  Note, the single-iteration and fully iterative Gauss-Newton style smoothers are only defined for MDA compatible values of lag and shift where the lag is an integer multiple of the shift.","category":"page"},{"location":"submodules/experiments/SmootherExps/","page":"SmootherExps","title":"SmootherExps","text":"Currently debugged and validated smoother experiment configurations include","category":"page"},{"location":"submodules/experiments/SmootherExps/","page":"SmootherExps","title":"SmootherExps","text":"classic_state          -- classic EnKS style state estimation\nclassic_param          -- classic EnKS style state-parameter estimation\nsingle_iteration_state -- single-iteration EnKS state estimation\nsingle_iteration_param -- single-iteration EnKS state-parameter estimation\niterative_state        -- Gauss-Newton style state estimation\niterative_param        -- Gauss-Newton style state-parameter estimation","category":"page"},{"location":"submodules/experiments/SmootherExps/","page":"SmootherExps","title":"SmootherExps","text":"Other techniques are still in debugging and validation.  Each of these takes an analysis type as used in the transform function in the EnsembleKalmanSchemes.jl sub-module, like the filter analyses in the filter experiments.","category":"page"},{"location":"submodules/experiments/SmootherExps/","page":"SmootherExps","title":"SmootherExps","text":"All experiments are funcitonalized so that they can be called from an array of parameter values which will typically be varied with naive parallelism.  Relevant arguments and experimental results are dumped as a side effect to a dictionary in a JLD2. Experiments return their runtime in minutes.","category":"page"},{"location":"submodules/experiments/SmootherExps/#Docstrings","page":"SmootherExps","title":"Docstrings","text":"","category":"section"},{"location":"submodules/experiments/SmootherExps/","page":"SmootherExps","title":"SmootherExps","text":"Modules = [DataAssimilationBenchmarks.SmootherExps]","category":"page"},{"location":"submodules/experiments/SmootherExps/#DataAssimilationBenchmarks.SmootherExps.classic_param-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :lag, :shift, :obs_un, :obs_dim, :Î³, :p_err, :p_wlk, :N_ens, :s_infl, :p_infl), <:Tuple{String, String, Int64, Int64, Int64, Int64, Float64, Int64, Float64, Float64, Float64, Int64, Float64, Float64}}}","page":"SmootherExps","title":"DataAssimilationBenchmarks.SmootherExps.classic_param","text":"classic_param((time_series::String, method::String, seed::Int64, nanl::Int64, lag::Int64,\n               shift::Int64, obs_un::Float64, obs_dim::Int64, Î³::Float64, p_err::Float64,\n               p_wlk::Float64, N_ens::Int64, s_infl::Float64,\n               s_infl::Float64})::NamedTuple)\n\nClassic ensemble Kalman smoother joint state-parameter estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments. NOTE: the classic scheme does not use multiple data assimilation and we hard code mda=false in the function for consistency with other methods.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/SmootherExps/#DataAssimilationBenchmarks.SmootherExps.classic_state-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :lag, :shift, :obs_un, :obs_dim, :Î³, :N_ens, :s_infl), <:Tuple{String, String, Int64, Int64, Int64, Int64, Float64, Int64, Float64, Int64, Float64}}}","page":"SmootherExps","title":"DataAssimilationBenchmarks.SmootherExps.classic_state","text":"classic_state((time_series::String, method::String, seed::Int64, nanl::Int64, lag::Int64,\n               shift::Int64, obs_un::Float64, obs_dim::Int64, Î³::Float64, N_ens::Int64, \n               s_infl::Float64)::NamedTuple)\n\nClassic ensemble Kalman smoother state estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments. NOTE: the classic scheme does not use multiple data assimilation and we hard code mda=false in the function for consistency with other methods.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/SmootherExps/#DataAssimilationBenchmarks.SmootherExps.iterative_param-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :lag, :shift, :mda, :obs_un, :obs_dim, :Î³, :p_err, :p_wlk, :N_ens, :s_infl, :p_infl), <:Tuple{String, String, Int64, Int64, Int64, Int64, Bool, Float64, Int64, Float64, Float64, Float64, Int64, Float64, Float64}}}","page":"SmootherExps","title":"DataAssimilationBenchmarks.SmootherExps.iterative_param","text":"iterative_param((time_series:String, method:String, seed::Int64, nanl::Int64, lag::Int64,\n                 shift::Int64, mda::Bool, obs_un::Float64, obs_dim::Int64, Î³::Float64,\n                 p_err::Float64, p_wlk::Float64, N_ens::Int64,\n                 s_infl::Float64, p_infl::Float64})\n\n4DEnVAR joint state-parameter estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/SmootherExps/#DataAssimilationBenchmarks.SmootherExps.iterative_state-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :lag, :shift, :mda, :obs_un, :obs_dim, :Î³, :N_ens, :s_infl), <:Tuple{String, String, Int64, Int64, Int64, Int64, Bool, Float64, Int64, Float64, Int64, Float64}}}","page":"SmootherExps","title":"DataAssimilationBenchmarks.SmootherExps.iterative_state","text":"iterative_state(args::Tuple{String,String,Int64,Int64,Int64,Int64,Bool,Float64, \n                            Int64,Float64,Int64,Float64})\n\n4DEnVAR state estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/SmootherExps/#DataAssimilationBenchmarks.SmootherExps.single_iteration_param-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :lag, :shift, :mda, :obs_un, :obs_dim, :Î³, :p_err, :p_wlk, :N_ens, :s_infl, :p_infl), <:Tuple{String, String, Int64, Int64, Int64, Int64, Bool, Float64, Int64, Float64, Float64, Float64, Int64, Float64, Float64}}}","page":"SmootherExps","title":"DataAssimilationBenchmarks.SmootherExps.single_iteration_param","text":"single_iteration_param((time_series::String, method::String, seed:Int64, nanl::Int64,\n                        lag::Int64, shift::Int64, mda::Bool, obs_un::Float64,\n                        obs_dim::Int64, Î³::Float64, p_err::Float64, p_wlk::Float64,\n                        N_ens::Int64, s_infl::Float64, p_infl::Float64)::NamedTuple)\n\nSIEnKS joint state-parameter estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/SmootherExps/#DataAssimilationBenchmarks.SmootherExps.single_iteration_state-Tuple{NamedTuple{(:time_series, :method, :seed, :nanl, :lag, :shift, :mda, :obs_un, :obs_dim, :Î³, :N_ens, :s_infl), <:Tuple{String, String, Int64, Int64, Int64, Int64, Bool, Float64, Int64, Float64, Int64, Float64}}}","page":"SmootherExps","title":"DataAssimilationBenchmarks.SmootherExps.single_iteration_state","text":"single_iteration_state((time_series::String, method::String, seed::Int64, nanl::Int64,\n                        lag::Int64, shift::Int64, mda::Bool, obs_un::Float64,\n                        obs_dim::Int64, Î³::Float64, N_ens::Int64,\n                        s_infl::Float64})::NamedTuple)\n\nSIEnKS state estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"home/Getting Started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"home/Getting Started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The main module DataAssimilationBenchmarks.jl declares global types and wraps sub-modules including the core numerical solvers for ordinary and stochastic differential equations, solvers for data assimilation routines and the core process model code for running twin experiments with benchmark models. These methods can be run stand-alone in other programs by calling these functions from the DeSolvers, EnsembleKalmanSchemes, L96 and IEEE39bus sub-modules from this library. Future solvers and models will be added as sub-modules in the methods and models directories respectively.","category":"page"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In order to get the full functionality of this package you will need to install the dev version. This provides the access to edit all of the outer-loop routines for setting up twin experiments. These routines are defined in the modules in the experiments directory. The slurm_submit_scripts directory includes routines for parallel submission of experiments in Slurm. Data processing scripts and visualization scripts (written in Python with Matplotlib and Seaborn) are included in the \"analysis\" directory.","category":"page"},{"location":"home/Getting Started/#Installing-a-dev-package-from-the-Julia-General-registries","page":"Getting Started","title":"Installing a dev package from the Julia General registries","text":"","category":"section"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"In order to install the dev version to your Julia environment, you can use the following commands in the REPL","category":"page"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"pkg> dev DataAssimilationBenchmarks","category":"page"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The installed version will be included in your","category":"page"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"~/.julia/dev/","category":"page"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"on Linux and the analogous directory with respect Windows and Mac systems. Alternatively, you can install this from the main Github branch directly as follows:","category":"page"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"pkg> dev https://github.com/cgrudz/DataAssimilationBenchmarks.jl","category":"page"},{"location":"home/Getting Started/#Repository-structure","page":"Getting Started","title":"Repository structure","text":"","category":"section"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"The repository is structured as follows:","category":"page"},{"location":"home/Getting Started/","page":"Getting Started","title":"Getting Started","text":"<ul>\n  <li><code>src</code> - contains the main parent module</li>\n  <ul>\n\t\t<li><code>models</code> - contains code for defining the dynamic model equations in twin\n\t\texperiments.</li>\n\t\t<li><code>methods</code> - contains DA solvers and general numerical routines for running\n\t\ttwin experiments.</li>\n\t\t<li><code>experiments</code> - contains the outer-loop scripts that set up twin\n\t\texperiments.</li>\n\t\t<li><code>data</code> - this is an input / output directory for the inputs to and\n\t\touptuts fromexperiments.</li>\n\t\t<li><code>analysis</code> - contains auxilliary scripts for batch processing experiment\n\t\tresults and for plotting in Python.</li>\n\t</ul>\n  <li><code>scratch</code> - this is a storage directory for backups.</li>\n  <li><code>test</code> - contains test cases for the package.</li>\n\t<li><code>docs</code> - contains the documenter files.</li>\n</ul>","category":"page"},{"location":"submodules/analysis/PlotExperimentData/#Analysis","page":"PlotExperimentData","title":"Analysis","text":"","category":"section"},{"location":"submodules/analysis/PlotExperimentData/#Processing-experiment-outputs","page":"PlotExperimentData","title":"Processing experiment outputs","text":"","category":"section"},{"location":"submodules/analysis/PlotExperimentData/","page":"PlotExperimentData","title":"PlotExperimentData","text":"The analysis directory contains scripts for batch processing the outputs from experiments into time-averaged RMSE and spread and arranging these outputs in an array for plotting.  This should be modified based on the local paths to stored data.  This will try to load files based on parameter settings written in the name of the output .jld2 file and if this is not available, this will store Inf values in the place of missing data.","category":"page"},{"location":"submodules/analysis/PlotExperimentData/#Validating-results","page":"PlotExperimentData","title":"Validating results","text":"","category":"section"},{"location":"submodules/analysis/PlotExperimentData/","page":"PlotExperimentData","title":"PlotExperimentData","text":"Benchmark configurations for the above filtering and smoothing experiments are available in the open access article A fast, single-iteration ensemble Kalman smoother for sequential data assimilation, with details on the algorithm and parameter specifications discussed in the experiments section.  Performance of filtering and smoothing schemes should be validated versus the numerical results presented there for root mean square error and ensemble spread. Simple versions of these diagnostics are built for automatic testing of the filter and smoother experiments for state and parameter estimation in the L96-s model.  Further test cases are currently in development.  The deterministic Runge-Kutta and Euler scheme for ODEs are validated in the package tests, estimating the order of convergence with the least-squares log-10 line fit between step size and discretization error.  Test cases for the stochastic integration schemes are in development, but numerical results with these schemes can be validated versus the results in the open-access article  On the numerical integration of the Lorenz-96 model, with scalar additive noise, for benchmark twin experiments.","category":"page"},{"location":"submodules/experiments/ParallelExperimentDriver/#ParallelExperimentDriver","page":"ParallelExperimentDriver","title":"ParallelExperimentDriver","text":"","category":"section"},{"location":"submodules/experiments/ParallelExperimentDriver/#ParallelExperimentDriver-API","page":"ParallelExperimentDriver","title":"ParallelExperimentDriver API","text":"","category":"section"},{"location":"submodules/experiments/ParallelExperimentDriver/","page":"ParallelExperimentDriver","title":"ParallelExperimentDriver","text":"The ParallelExperimentDriver.jl is a simple parallel implementation, though currently lacks a soft-fail when numerical instability is encountered.  This means that if a single experiment configuration in the collection fails due to overflow, the entire collection will cancel.  A fix for this is being explored, but the recommendation is to use the slurm submit scripts below as templates for generating large parameter grid configurations and running them on servers.","category":"page"},{"location":"submodules/experiments/ParallelExperimentDriver/#Docstrings","page":"ParallelExperimentDriver","title":"Docstrings","text":"","category":"section"},{"location":"submodules/experiments/ParallelExperimentDriver/","page":"ParallelExperimentDriver","title":"ParallelExperimentDriver","text":"#@autodocs #Modules = [DataAssimilationBenchmarks.ParallelExperimentDriver] #","category":"page"},{"location":"submodules/methods/DeSolvers/#Differential-Equation-Solvers","page":"DeSolvers","title":"Differential Equation Solvers","text":"","category":"section"},{"location":"submodules/methods/DeSolvers/#API-for-differential-equation-solvers","page":"DeSolvers","title":"API for differential equation solvers","text":"","category":"section"},{"location":"submodules/methods/DeSolvers/","page":"DeSolvers","title":"DeSolvers","text":"Three general schemes are developed for ordinary and stochastic differential equations, the four-stage Runge-Kutta DataAssimilationBenchmarks.DeSolvers.rk4_step!, second order autonomous Taylor DataAssimilationBenchmarks.DeSolvers.tay2_step!, and the Euler-(Maruyama) DataAssimilationBenchmarks.DeSolvers.em_step! schemes. Because the second order Taylor-Stratonovich scheme relies specifically on the structure of the Lorenz-96 model with additive noise, this is included separately in the L96 sub-module.  The time steppers over-write the value of the model state x in place as a vector or a view of an array for efficient ensemble integration.  This follows the convention in data assimilation of the extended state formalism for parameter estimation where the parameter sample should be included as trailing state variables in the columns of the ensemble array.  If","category":"page"},{"location":"submodules/methods/DeSolvers/","page":"DeSolvers","title":"DeSolvers","text":"true == haskey(kwargs, \"param_sample\")","category":"page"},{"location":"submodules/methods/DeSolvers/","page":"DeSolvers","title":"DeSolvers","text":"the state_dim parameter specifies the dimension of the dynamical states and creates a view of the vector x including all entries up to this index.  The remaining entries in the state vector x will be passed to the dx_dt function in a dictionary merged with the dx_params  ParamDict, according to the param_sample indices and parameter values specified in param_sample. The parameter sample values will remain unchanged by the time stepper when the dynamical state entries in x are over-written in place.","category":"page"},{"location":"submodules/methods/DeSolvers/","page":"DeSolvers","title":"DeSolvers","text":"Setting diffusion > 0.0 introduces additive noise to the dynamical system.  The main DataAssimilationBenchmarks.DeSolvers.rk4_step! has convergence on order 4.0 when diffusion is equal to zero, and both strong and weak convergence on order 1.0 when stochasticity is introduced.  This is the recommended out-of-the-box solver for any generic DA simulation for the statistically robust performance, versus Euler-(Maruyama).  When specifically generating the truth-twin for the Lorenz-96 model with additive noise, this should be performed with the DataAssimilationBenchmarks.L96.l96s_tay2_step!, while the ensemble should be generated with the DataAssimilationBenchmarks.DeSolvers.rk4_step!.  See the benchmarks on the L96-s model for a full discussion of statistically robust model configurations.","category":"page"},{"location":"submodules/methods/DeSolvers/#Methods","page":"DeSolvers","title":"Methods","text":"","category":"section"},{"location":"submodules/methods/DeSolvers/","page":"DeSolvers","title":"DeSolvers","text":"Modules = [DataAssimilationBenchmarks.DeSolvers]","category":"page"},{"location":"submodules/methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.StepKwargs","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.StepKwargs","text":"StepKwargs = Dict{String,Any}\n\nKey word arguments for model time steppers. Arguments are given as:\n\n    REQUIRED:\n    dx_dt        -- time derivative function with arguments x and dx_params\n    dx_params    -- parameters necessary to resolve dx_dt, not including\n                    parameters to be estimated in the extended state vector \n    h            -- numerical discretization step size\n\n    OPTIONAL:\n    diffusion    -- tunes the standard deviation of the Wiener process, \n                    equal to sqrt(h) * diffusion\n    diff_mat     -- structure matrix for the diffusion coefficients,\n                    replaces the default uniform scaling \n    state_dim    -- keyword for parameter estimation, dimension of the\n                    dynamic state < dimension of full extended state\n    param_sample -- ParamSample dictionary for merging extended state with dx_params\n    Î¾            -- random array size state_dim, can be defined in kwargs\n                    to provide a particular realization for method validation\n\n\n\n\n\n","category":"type"},{"location":"submodules/methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.em_step!-Tuple{Vector{Float64}, Float64, Dict{String, Any}}","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.em_step!","text":"em_step!(x::Vector{Float64}, t::Float64, kwargs::Dict{String,Any})\n\nThis will propagate the state x one step forward by Euler-Murayama scheme. Arguments are given as:\n\n    x      -- array or sub-array of a model states possibly including static parameter values\n    t      -- time value for present model state\n    kwargs -- includes state time derivative dx_dt, paramters for the dx_dt and optionals\n\nwhere kwargs is type StepKwargs Details on this scheme are available in the manuscript Grudzien, C. et al.: On the numerical integration of the Lorenz-96 model, with scalar additive noise, for benchmark twin experiments, Geosci. Model Dev., 13, 1903â1924, https://doi.org/10.5194/gmd-13-1903-2020, 2020.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.rk4_step!-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Dict{String, Any}}","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.rk4_step!","text":"rk4_step!(x::VecA, t::Float64, kwargs::StepKwargs)\n\nStep of integration rule for 4 stage Runge-Kutta as discussed in Grudzien et al. 2020. The rule has strong convergence order 1.0 for generic SDEs and order 4.0 for ODEs. Arguments are given as:\n\n    x      -- array or sub-array of a model states possibly including static parameter values\n    t      -- time value for present model state\n    kwargs -- includes state time derivative dx_dt, paramters for the dx_dt and optionals\n\nwhere kwargs is type StepKwargs Details on this scheme are available in the manuscript Grudzien, C. et al.: On the numerical integration of the Lorenz-96 model, with scalar additive noise, for benchmark twin experiments, Geosci. Model Dev., 13, 1903â1924, https://doi.org/10.5194/gmd-13-1903-2020, 2020.\n\n\n\n\n\n","category":"method"},{"location":"submodules/methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.tay2_step!-Tuple{Vector{Float64}, Float64, Dict{String, Any}}","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.tay2_step!","text":"tay2_step!(x::Vector{Float64}, t::Float64, kwargs::Dict{String,Any})\n\nDeterministic second order autonomous Taylor method for step size h and state vector x. Time variable t is just a dummy variable, where this method is not defined for non-autonomous dynamics.  Arguments are given as:\n\n    x      -- array of a single state possibly including parameter values\n    kwargs -- includes state time derivative dx_dt, paramters for the dx_dt and optionals\n\nwhere kwargs is type StepKwargs.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/Slurm/#Slurm","page":"Slurm","title":"Slurm","text":"","category":"section"},{"location":"submodules/experiments/Slurm/#SlurmExperimentDrivers","page":"Slurm","title":"SlurmExperimentDrivers","text":"","category":"section"},{"location":"submodules/experiments/Slurm/","page":"Slurm","title":"Slurm","text":"These are a collection of templates for automatically generating an array of parameter tuples to pass to the experiment functions as configurations.  This uses a simple looping strategy, while writing out the configurations to a .jld2 file to be read by the parallel experiment driver within the slurm_submit_scripts directory.  The paralell submit script  should be run within the slurm_submit_scripts directory to specify the correct paths to the time series data, the experiment configuration data and to save to the correct output directory, specified by the method used.","category":"page"},{"location":"submodules/experiments/GenerateTimeSeries/#GenerateTimeSeries","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"","category":"section"},{"location":"submodules/experiments/GenerateTimeSeries/#GenerateTimeSeries-2","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"","category":"section"},{"location":"submodules/experiments/GenerateTimeSeries/","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"GenerateTimeSeries is a sub-module used to generate a time series for a twin experiment based on tuneable configuration parameters.  Currently, this only includes the L96s model, with parameters defined as","category":"page"},{"location":"submodules/experiments/GenerateTimeSeries/","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"l96_time_series(args::Tuple{Int64,Int64,Float64,Int64,Int64,Float64,Float64})\nseed, state_dim, tanl, nanl, spin, diffusion, F = args","category":"page"},{"location":"submodules/experiments/GenerateTimeSeries/","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"The args tuple includes the pseudo-random seed seed, the size of the Lorenz system state_dim, the length of continuous time in between sequential observations / analyses tanl, the number of observations / analyses to be saved nanl, the length of the warm-up integration of the dynamical system solution to guarantee an observation generating process on the attractor spin, the diffusion parameter determining the intensity of the random perturbations diffusion and the forcing parameter F.  This automates the selection of the correct time stepper for the truth twin when using deterministic or stochastic integration.  Results are saved in .jld2 format in the data directory.","category":"page"},{"location":"submodules/experiments/GenerateTimeSeries/#Docstrings","page":"GenerateTimeSeries","title":"Docstrings","text":"","category":"section"},{"location":"submodules/experiments/GenerateTimeSeries/","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"Modules = [DataAssimilationBenchmarks.GenerateTimeSeries]","category":"page"},{"location":"submodules/experiments/GenerateTimeSeries/#DataAssimilationBenchmarks.GenerateTimeSeries.IEEE39bus_time_series-Tuple{NamedTuple{(:seed, :tanl, :nanl, :spin, :diffusion), <:Tuple{Int64, Float64, Int64, Int64, Float64}}}","page":"GenerateTimeSeries","title":"DataAssimilationBenchmarks.GenerateTimeSeries.IEEE39bus_time_series","text":"IEEE39bus_time_series((seed::Int64, tanl::Float64, nanl::Int64, spin::Int64,\n                       diffusion::Float64)::NamedTuple)\n\nSimulate a \"free run\" time series of the IEEE 39 bus swing equation model for generating an observation process and truth twin for data assimilation twin experiments. Time stepping parameters, stochasticity of the dynamics, and system parameters are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"submodules/experiments/GenerateTimeSeries/#DataAssimilationBenchmarks.GenerateTimeSeries.L96_time_series-Tuple{NamedTuple{(:seed, :state_dim, :tanl, :nanl, :spin, :diffusion, :F), <:Tuple{Int64, Int64, Float64, Int64, Int64, Float64, Float64}}}","page":"GenerateTimeSeries","title":"DataAssimilationBenchmarks.GenerateTimeSeries.L96_time_series","text":"L96_time_series((seed::Int64, state_dim::Int64, tanl::Float64, nanl::Int64, spin::Int64,\n                 diffusion::Float64, F::Float64)::NamedTuple)\n\nSimulate a \"free run\" time series of the Lorenz-96 model for generating an observation process and truth twin for data assimilation twin experiments.  Time stepping parameters, stochasticity of the dynamics, and system parameters are specified in the named tuple arguments.\n\n\n\n\n\n","category":"method"},{"location":"submodules/models/IEEE39bus/#IEEE39-Bus-Swing-Equation-Model","page":"IEEE39bus","title":"IEEE39 Bus Swing Equation Model","text":"","category":"section"},{"location":"submodules/models/IEEE39bus/","page":"IEEE39bus","title":"IEEE39bus","text":"Modules = [DataAssimilationBenchmarks.IEEE39bus]","category":"page"},{"location":"submodules/models/IEEE39bus/#DataAssimilationBenchmarks.IEEE39bus.dx_dt-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}}","page":"IEEE39bus","title":"DataAssimilationBenchmarks.IEEE39bus.dx_dt","text":"dx_dt(x::VecA, t::Float64, dx_params::ParamDict)\n\nTime derivative of the phase and fequency of the effective-network swing equation model. Input x is a 2 n_g VecA of the phase and fequency at each of the n_g generator buses. The input dx_params of type ParamDict containing system parameters to be passed to the integration scheme.  The system is currenty defined autonomously to be run as an SDE, noise perturbed steady state.\n\n\n\n\n\n","category":"method"},{"location":"home/Introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"home/Introduction/#Statement-of-purpose","page":"Introduction","title":"Statement of purpose","text":"","category":"section"},{"location":"home/Introduction/","page":"Introduction","title":"Introduction","text":"The purpose of this package is to provide a research framework for the theoretical development and empirical validation of novel data assimilation techniques. While analytical proofs can be derived for classical methods such as the Kalman filter in linear-Gaussian dynamics, most currently developed DA techniques are designed for estimation in nonlinear, non-Gaussian models where no analytical solution may exist.  Novel data assimilation methods, therefore, must be studied with rigorous numerical simulation in standard test-cases to demonstrate the effectiveness and computational performance. Pursuant to proposing a novel DA method, one should likewise compare the performance of a proposed scheme with other standard methods within the same class of estimators.","category":"page"},{"location":"home/Introduction/","page":"Introduction","title":"Introduction","text":"This package implements a variety of standard data assimilation algorithms, including widely used performance modifications that are used in practice to tune these estimators. Standard libraries exist for full-scale DA system research and development, e.g., the Data Assimilation Research Testbed (DART), but there are fewer standard options for theoretical research and algorithm development in simple test systems. DataAssimilationBenchmarks.jl provides one framework for studying ensemble-based filters and sequential smoothers that are commonly used in online, geoscientific prediction settings.","category":"page"},{"location":"home/Introduction/#Validated-methods-currently-in-use","page":"Introduction","title":"Validated methods currently in use","text":"","category":"section"},{"location":"home/Introduction/","page":"Introduction","title":"Introduction","text":"For a discussion of the below methods and benchmarks for their validation, please see the manuscript A fast, single-iteration ensemble Kalman smoother for sequential data assimilation.","category":"page"},{"location":"home/Introduction/","page":"Introduction","title":"Introduction","text":"<table>\n<tr>\n\t<th>Estimator / implemented techniques</th>\n\t<th>Tuned multiplicative inflation</th>\n\t<th>Adaptive inflation, finite-size formalism (perfect model dual / primal)</th>\n\t<th>Adaptive inflation, finite-size formalism (imperfect model)</th>\n\t<th>Linesearch</th>\n\t<th>Localization / Hybridization</th>\n\t<th>Multiple data assimilation (general shift and lag)</th>\n</tr>\n<tr>\n  <td> EnKF, perturbed obs.</td>\n\t<td> X  </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> NA </td>\n\t<td>    </td>\n\t<td> NA </td>\n</tr>\n<tr>\n  <td> ETKF </td>\n\t<td> X  </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> NA </td>\n\t<td>    </td>\n\t<td> NA </td>\n</tr>\n<tr>\n  <td> MLEF, transform / bundle variants</td>\n\t<td> X  </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> NA </td>\n</tr>\n<tr>\n  <td> EnKS, perturbed obs.</td>\n\t<td> X  </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> NA </td>\n\t<td>    </td>\n\t<td> NA </td>\n</tr>\n<tr>\n  <td> ETKS</td>\n\t<td> X  </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> NA </td>\n\t<td>    </td>\n\t<td> NA </td>\n</tr>\n<tr>\n  <td> MLES, transform / bundle variants</td>\n\t<td> X  </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> X  </td>\n\t<td>    </td>\n\t<td> NA </td>\n</tr>\n<tr>\n  <td>SIEnKS, perturbed obs / ETKF / MLEF variants</td>\n\t<td> X </td>\n\t<td> X </td>\n\t<td>   </td>\n\t<td> X </td>\n\t<td>   </td>\n\t<td> X </td>\n</tr>\n<tr>\n  <td>Gauss-Newton IEnKS, transform / bundle variants</td>\n\t<td> X </td>\n\t<td> X </td>\n\t<td>   </td>\n\t<td>   </td>\n\t<td>   </td>\n\t<td> X </td>\n</tr>\n</table>","category":"page"},{"location":"submodules/analysis/ProcessExperimentData/#Analysis","page":"ProcessExperimentData","title":"Analysis","text":"","category":"section"},{"location":"submodules/analysis/ProcessExperimentData/#Processing-experiment-outputs","page":"ProcessExperimentData","title":"Processing experiment outputs","text":"","category":"section"},{"location":"submodules/analysis/ProcessExperimentData/","page":"ProcessExperimentData","title":"ProcessExperimentData","text":"The analysis directory contains scripts for batch processing the outputs from experiments into time-averaged RMSE and spread and arranging these outputs in an array for plotting.  This should be modified based on the local paths to stored data.  This will try to load files based on parameter settings written in the name of the output .jld2 file and if this is not available, this will store Inf values in the place of missing data.","category":"page"},{"location":"submodules/analysis/ProcessExperimentData/#Validating-results","page":"ProcessExperimentData","title":"Validating results","text":"","category":"section"},{"location":"submodules/analysis/ProcessExperimentData/","page":"ProcessExperimentData","title":"ProcessExperimentData","text":"Benchmark configurations for the above filtering and smoothing experiments are available in the open access article A fast, single-iteration ensemble Kalman smoother for sequential data assimilation, with details on the algorithm and parameter specifications discussed in the experiments section.  Performance of filtering and smoothing schemes should be validated versus the numerical results presented there for root mean square error and ensemble spread. Simple versions of these diagnostics are built for automatic testing of the filter and smoother experiments for state and parameter estimation in the L96-s model.  Further test cases are currently in development.  The deterministic Runge-Kutta and Euler scheme for ODEs are validated in the package tests, estimating the order of convergence with the least-squares log-10 line fit between step size and discretization error.  Test cases for the stochastic integration schemes are in development, but numerical results with these schemes can be validated versus the results in the open-access article  On the numerical integration of the Lorenz-96 model, with scalar additive noise, for benchmark twin experiments.","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a data assimilation research code base with an emphasis on prototyping, testing and validating sequential filters and smoothers in toy model twin experiments. This code is meant to be performant in the sense that large hyper-parameter discretizations can be explored to determine hyper-parameter sensitivity and reliability of results across different experimental regimes, with parallel implementations in native Julia distributed computing and using workload managers such as Slurm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package currently includes code for developing and testing data assimilation schemes in the L96-s model and the IEEE 39 bus test case in the form of the effective network model model equations. New toy models and data assimilation schemes are in continuous development in the development branch.  Currently validated techniques are available in the master branch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supported the development of all numerical results and benchmark simulations in the pre-print A fast, single-iteration ensemble Kalman smoother for sequential data assimilation available currently in open review in Geoscientific Model Development.","category":"page"},{"location":"submodules/models/L96/#Lorenz-96-model","page":"L96","title":"Lorenz-96 model","text":"","category":"section"},{"location":"submodules/models/L96/","page":"L96","title":"L96","text":"Modules = [DataAssimilationBenchmarks.L96]","category":"page"},{"location":"submodules/models/L96/#DataAssimilationBenchmarks.L96.compute_Î±_Ï-Tuple{Int64}","page":"L96","title":"DataAssimilationBenchmarks.L96.compute_Î±_Ï","text":"compute_Î±_Ï(p::Int64)\n\nComputes auxiliary functions for the 2nd order Taylor-Stratonovich expansion. The constants Î± and Ï need to be computed once, only as a function of the order of truncation of the Fourier series, the argument p, for the integration method.  These constants are then supplied as arguments to l96s_tay2_step! in kwargs. See l96s_tay2_step! for the interpretation and usage of these constants.\n\n\n\n\n\n","category":"method"},{"location":"submodules/models/L96/#DataAssimilationBenchmarks.L96.dx_dt-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}}","page":"L96","title":"DataAssimilationBenchmarks.L96.dx_dt","text":"dx_dt(x::VecA, t::Float64, dx_params::ParamDict)\n\nTime derivative for Lorenz-96 model, x is a  model state of size state_dim and type VecA, t is a dummy time argument for consistency with integration methods, dx_params is of type ParamDict which is called for the forcing parameter.\n\n\n\n\n\n","category":"method"},{"location":"submodules/models/L96/#DataAssimilationBenchmarks.L96.jacobian-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}}","page":"L96","title":"DataAssimilationBenchmarks.L96.jacobian","text":"jacobian(x::VecA, t::Float64, dx_params::ParamDict)\n\nComputes the Jacobian of Lorenz-96 about the state x of type VecA. The time variable t is a dummy variable for consistency with integration methods, dx_params is of type ParamDict which is called for the forcing parameter. Note that this is designed to load entries in a zeros array and return a sparse array to make a compromise between memory and computational resources.\n\n\n\n\n\n","category":"method"},{"location":"submodules/models/L96/#DataAssimilationBenchmarks.L96.l96s_tay2_step!-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Dict{String, Any}}","page":"L96","title":"DataAssimilationBenchmarks.L96.l96s_tay2_step!","text":"l96s_tay2_step!(x::VecA, t::Float64, kwargs::Dict{String,Any})\n\nOne step of integration rule for l96 second order taylor rule The constants Ï and Î± are to be computed with compute_Î±_Ï, depending only on p, and supplied for all steps. This is the general formulation which includes, e.g., dependence on the truncation of terms in the auxilliary function C with respect to the parameter p.  In general, truncation at p=1 is all that is necessary for order 2.0 convergence.\n\nThis method is derived in Grudzien, C. et al.: On the numerical integration of the Lorenz-96 model, with scalar additive noise, for benchmark twin experiments, Geosci. Model Dev., 13, 1903â1924, https://doi.org/10.5194/gmd-13-1903-2020, 2020. NOTE: this Julia version still pending validation as in the above manuscript\n\n\n\n\n\n","category":"method"},{"location":"submodules/models/L96/#DataAssimilationBenchmarks.L96.mod_indx!-Tuple{Int64, Int64}","page":"L96","title":"DataAssimilationBenchmarks.L96.mod_indx!","text":"mod_indx!(indx::Int64, dim::Int64)\n\nAuxiliary function to return state vector indices for the Lorenz-96 model, where indx is taken mod dim.  Mod zero is replaced with dim for indexing in Julia state vectors.\n\n\n\n\n\n","category":"method"}]
}
