<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>EnsembleKalmanSchemes · DataAssimilationBenchmarks</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DataAssimilationBenchmarks</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../models/L96/">L96</a></li><li><a class="tocitem" href="../../models/IEEE39bus/">IEEE39bus</a></li></ul></li><li><span class="tocitem">Methods</span><ul><li><a class="tocitem" href="../DeSolvers/">DeSolvers</a></li><li class="is-active"><a class="tocitem" href>EnsembleKalmanSchemes</a></li></ul></li><li><span class="tocitem">Experiments</span><ul><li><a class="tocitem" href="../../experiments/GenerateTimeSeries/">GenerateTimeSeries</a></li><li><a class="tocitem" href="../../experiments/FilterExps/">FilterExperiments</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Methods</a></li><li class="is-active"><a href>EnsembleKalmanSchemes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>EnsembleKalmanSchemes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/master/docs/src/methods/EnsembleKalmanSchemes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Ensemble-Kalman-Schemes"><a class="docs-heading-anchor" href="#Ensemble-Kalman-Schemes">Ensemble Kalman Schemes</a><a id="Ensemble-Kalman-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-Kalman-Schemes" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ArView" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ArView"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ArView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ArView = Union{Array{Float64, 2}, SubArray{Float64, 2}}</code></pre><p>Type union of arrays and views of arrays for use within ensemble conditioning operations, integration schemes and other array operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ConM" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ConM"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ConM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConM = Union{UniformScaling{Float64}, Symmetric{Float64}}</code></pre><p>Type union of conditioning matrix types, which will be used for optimization routines in the transform method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.CovM" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.CovM"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.CovM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CovM = Union{UniformScaling{Float64}, Diagonal{Float64}, Symmetric{Float64}}</code></pre><p>Type union of covariance matrix types, for optimized computation based on characteristics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.TransM" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.TransM"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.TransM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransM = Union{Tuple{Symmetric{Float64,Array{Float64,2}},Array{Float64,2},Array{Float64,2}},
               Tuple{Symmetric{Float64,Array{Float64,2}},Array{Float64,1},Array{Float64,2}},
               Array{Float64,2}}</code></pre><p>Type union of right transform types, including soley a transform, or a transform, weights and rotation package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L33-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.VecA" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.VecA"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.VecA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VecA = Union{Vector{Float64}, SubArray{Float64, 1}}</code></pre><p>Type union of vectors and ensemble members of sample for using in integration schemes and related array operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L45-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator-Tuple{Matrix{Float64}, Int64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator-Tuple{Matrix{Float64}, Int64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alternating_obs_operator(ens::Array{Float64,2}, obs_dim::Int64, 
                         kwargs::Dict{String,Any})</code></pre><p>Observation of alternating state vector components, possibly nonlinear transformation. This selects components to observe based on the observation dimension and if parameter estimation is being performed.  Parameters are always unobservable, and even states will be removed from the state vector until the observation dimension is appropriate.  Nonlinear observations are optional, as described for the Lorenz-96 model by Asch, Bocquet, Nodet pg. 181.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L65-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analyze_ens(ens::ArView, truth::Vector{Float64})</code></pre><p>Computes the ensemble RMSE as compared with truth twin, and the ensemble spread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analyze_ens_para(ens::ArView, truth::Vector{Float64})</code></pre><p>Computes the ensemble RMSE as compared with truth twin, and the ensemble spread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!-Union{Tuple{T1}, Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, T1}} where T1&lt;:Union{Tuple{Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}}, Tuple{Symmetric{Float64, Matrix{Float64}}, Vector{Float64}, Matrix{Float64}}, Matrix{Float64}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!-Union{Tuple{T1}, Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, T1}} where T1&lt;:Union{Tuple{Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}}, Tuple{Symmetric{Float64, Matrix{Float64}}, Vector{Float64}, Matrix{Float64}}, Matrix{Float64}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ens_update!(ens::ArView, transform::T1) where {T1 &lt;: TransM}</code></pre><p>Updates ensemble by right-transform method. In the case where this follows the stochastic EnKF as in Carrassi et al. 2018, this simply performs right mutliplication.  All other cases use the 3-tuple including the right transform for the anomalies, the weights for the mean and the random, mean-preserving orthogonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L1015-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ensemble_filter(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},  
                obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})</code></pre><p>General filter analysis step, wrapping the transform / update, and inflation steps. Optional keyword argument includes state_dim for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L1047-L1055">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!-Tuple{Matrix{Float64}, Float64, Int64, Int64}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!-Tuple{Matrix{Float64}, Float64, Int64, Int64}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inflate_param!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, 
               state_dim::Int64)</code></pre><p>Parameter variable multiplicative covariance inflation. State variables are assumed to be in the leading rows, while extended state, parameter variables are after. Multiplicative inflation is performed only in the trailing components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L243-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!-Tuple{Matrix{Float64}, Float64, Int64, Int64}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!-Tuple{Matrix{Float64}, Float64, Int64, Int64}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inflate_state!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, 
               state_dim::Int64)</code></pre><p>Dynamic state variable multiplicative covariance inflation.  State variables are assumed to be in the leading rows, while extended state variables, parameter variables are after. Multiplicative inflation is performed only in the leading components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L221-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ls_smoother_classic(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},  
                    obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})</code></pre><p>Lag-shift ensemble kalman smoother analysis step, classical version. Classic enks uses the last filtered state for the forecast, different from the  iterative schemes which use the once or multiple-times re-analized posterior for the initial condition for the forecast of the states to the next shift.</p><p>Optional argument includes state dimension for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L1088-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ls_smoother_gauss_newton(analysis::String, ens::Array{Float64,2},                   
                         obs::Array{Float64,2}, obs_cov::CovM, state_infl::Float64,
                         kwargs::Dict{String,Any}; ϵ::Float64=0.0001,
                         tol::Float64=0.001, max_iter::Int64=5)</code></pre><p>Lag-shift Gauss-Newton IEnKS analysis step, algorithm 4, Bocquet &amp; Sakov 2014 ienks uses the final re-analyzed posterior initial state for the forecast,  which is pushed forward in time from the initial conidtion to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L1497-L1509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Float64, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ls_smoother_single_iteration(analysis::String, ens::Array{Float64,2},       
                             obs::Array{Float64,2}, obs_cov::CovM,
                             state_infl::Float64, kwargs::Dict{String,Any})</code></pre><p>Lag-shift ensemble kalman smoother analysis step, single iteration version. Single-iteration enks uses the final re-analyzed posterior initial state for the forecast, which is pushed forward in time to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L1212-L1223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth-Tuple{Int64}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth-Tuple{Int64}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_orth(N_ens::Int64)</code></pre><p>This generates a random. mean preserving, orthogonal matrix as in Sakov &amp; Oke 2008.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root-Tuple{T} where T&lt;:Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root-Tuple{T} where T&lt;:Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_root(M::T) where {T &lt;: CovM}</code></pre><p>Auxiliary function for computing the square roots of multiple types of covariance matrices, with the subroutines defined according to the sub-type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L265-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv-Tuple{T} where T&lt;:Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv-Tuple{T} where T&lt;:Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">square_root_inv(M::T) where {T &lt;: CovM}</code></pre><p>Auxiliary function for computing the square root inverse of multiple types of covariance matrices, with the subroutines defined according to the sub-type. This will optionally return a computation of the inverse and the square root itself all as a byproduct of the singular value decomposition computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L286-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Dict{String, Any}}" href="#DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V&lt;:AbstractVector{Float64}, Symmetric{Float64, S} where S&lt;:(AbstractMatrix{&lt;:Float64})}, Dict{String, Any}}"><code>DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},        
       obs_cov::CovM, kwargs::Dict{String,Any}; conditioning::ConM=1000.0I, 
       m_err::Array{Float64,2}=(1.0 ./ zeros(1,1)),
       tol::Float64 = 0.0001,
       j_max::Int64=40,
       Q::CovM=1.0I)</code></pre><p>Computes transform and related values for various flavors of ensemble Kalman schemes. Serves as an auxilliary function for EnKF, ETKF(-N), EnKS, ETKS(-N), IEnKS(-N), where &quot;analysis&quot; is a string which determines the type of transform update.  The observation error covariance should be of UniformScaling, Diagonal or Symmetric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cgrudz/DataAssimilationBenchmarks/blob/7ed8177b247272dfcb8b7d4623c027cf3b781d31/src/methods/EnsembleKalmanSchemes.jl#L353-L365">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DeSolvers/">« DeSolvers</a><a class="docs-footer-nextpage" href="../../experiments/GenerateTimeSeries/">GenerateTimeSeries »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Wednesday 6 April 2022 17:59">Wednesday 6 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
