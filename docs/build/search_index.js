var documenterSearchIndex = {"docs":
[{"location":"experiments/GenerateTimeSeries/#GenerateTimeSeries","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"","category":"section"},{"location":"experiments/GenerateTimeSeries/","page":"GenerateTimeSeries","title":"GenerateTimeSeries","text":"Modules = [DataAssimilationBenchmarks.GenerateTimeSeries]","category":"page"},{"location":"experiments/GenerateTimeSeries/#DataAssimilationBenchmarks.GenerateTimeSeries.IEEE39bus_time_series-Tuple{Tuple{Int64, Float64, Int64, Int64, Float64}}","page":"GenerateTimeSeries","title":"DataAssimilationBenchmarks.GenerateTimeSeries.IEEE39bus_time_series","text":"IEEE39bus_time_series(args::Tuple{Int64,Float64,Int64,Int64,Float64})\n\nSimulate a \"free run\" time series of the IEEE 39 bus swing equation model for generating an observation process and truth twin for data assimilation twin experiments. Time stepping parameters, stochasticity of the dynamics, and system parameters are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"experiments/GenerateTimeSeries/#DataAssimilationBenchmarks.GenerateTimeSeries.L96_time_series-Tuple{Tuple{Int64, Int64, Float64, Int64, Int64, Float64, Float64}}","page":"GenerateTimeSeries","title":"DataAssimilationBenchmarks.GenerateTimeSeries.L96_time_series","text":"L96_time_series(args::Tuple{Int64,Int64,Float64,Int64,Int64,Float64,Float64})\n\nSimulate a \"free run\" time series of the Lorenz-96 model for generating an observation process and truth twin for data assimilation twin experiments.  Time stepping parameters, stochasticity of the dynamics, and system parameters are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"methods/DeSolvers/#Differential-Equation-Solvers","page":"DeSolvers","title":"Differential Equation Solvers","text":"","category":"section"},{"location":"methods/DeSolvers/","page":"DeSolvers","title":"DeSolvers","text":"Modules = [DataAssimilationBenchmarks.DeSolvers]","category":"page"},{"location":"methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.ParamDict","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.ParamDict","text":"ParamDict = Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}\n\nDictionary for model parameters to be passed to derivative functions by name.\n\n\n\n\n\n","category":"type"},{"location":"methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.VecA","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.VecA","text":"VecA = Union{Vector{Float64}, SubArray{Float64, 1}}\n\nType union of vectors and ensemble members of sample for using in integration schemes and related array operations.\n\n\n\n\n\n","category":"type"},{"location":"methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.ParamSample","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.ParamSample","text":"ParamSample = Dict{String, Vector{UnitRange{Int64}}}\n\nDictionary containing key and index pairs to subset the state vector and then merge with dx_params in parameter estimation problems.\n\n\n\n\n\n","category":"type"},{"location":"methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.em_step!-Tuple{Vector{Float64}, Float64, Dict{String, Any}}","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.em_step!","text":"em_step!(x::Vector{Float64}, t::Float64, kwargs::Dict{String,Any})\n\nThis will propagate the state x one step forward by Euler-Murayama scheme. Step size is h, the Wiener process is assumed to have a scalar diffusion coefficient.\n\n\n\n\n\n","category":"method"},{"location":"methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.rk4_step!-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Dict{String, Any}}","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.rk4_step!","text":"rk4_step!(x::VecA, t::Float64, kwargs::Dict{String,Any})\n\nStep of integration rule for 4 stage Runge-Kutta as discussed in Grudzien et al. 2020. The rule has strong convergence order 1.0 for generic SDEs and order 4.0 for ODEs. Arguments are given as:\n\nx            -- array or sub-array of a single state possibly including parameter values\nt            -- time point\nkwargs       -- should include dx_dt, the paramters for the dx_dt and optional arguments\ndx_dt        -- time derivative function with arguments x and dx_params\ndx_params    -- parameters necessary to resolve dx_dt, not including\n                parameters to be estimated in the extended state vector \nh            -- numerical discretization step size\ndiffusion    -- tunes the standard deviation of the Wiener process, \n                equal to sqrt(h) * diffusion\ndiff_mat     -- structure matrix for the diffusion coefficients,\n                replaces the default uniform scaling \nstate_dim    -- keyword for parameter estimation, dimension of the\n                dynamic state < dimension of full extended state\nparam_sample -- ParamSample dictionary for merging extended state with dx_params\nξ            -- random array size state_dim, can be defined in kwargs\n                to provide a particular realization for method validation\n\n\n\n\n\n","category":"method"},{"location":"methods/DeSolvers/#DataAssimilationBenchmarks.DeSolvers.tay2_step!-Tuple{Vector{Float64}, Float64, Dict{String, Any}}","page":"DeSolvers","title":"DataAssimilationBenchmarks.DeSolvers.tay2_step!","text":"tay2_step!(x::Vector{Float64}, t::Float64, kwargs::Dict{String,Any})\n\nDeterministic second order (autonomous) Taylor method for step size h and state vector x. Time variable t is just a dummy variable, where this method is not defined for non-autonomous dynamics.  Arguments are given as     x          – array of a single state possibly including parameter values     kwargs     – should include dxdt, the paramters for the dxdt and optional arguments     dxdt      – time derivative function with arguments x and dxparams     dxparams  – parameters necessary to resolve dxdt, not including                   parameters to be estimated in the extended state vector      h          – numerical discretization step size\n\n\n\n\n\n","category":"method"},{"location":"models/L96/#Lorenz-96-model","page":"L96","title":"Lorenz-96 model","text":"","category":"section"},{"location":"models/L96/","page":"L96","title":"L96","text":"Modules = [DataAssimilationBenchmarks.L96]","category":"page"},{"location":"models/L96/#DataAssimilationBenchmarks.L96.dx_dt-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}}","page":"L96","title":"DataAssimilationBenchmarks.L96.dx_dt","text":"dx_dt(x::VecA, t::Float64, dx_params::ParamDict)\n\nTime derivative for Lorenz-96 model, x is a single model state of size state_dim, t\nis a dummy time argument for consistency with integration methods, dx_params is a \nparameter dictionary which is called for the forcing parameter.\n\n\n\n\n\n","category":"method"},{"location":"models/L96/#DataAssimilationBenchmarks.L96.jacobian-Tuple{Vector{Float64}, Float64, Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}}","page":"L96","title":"DataAssimilationBenchmarks.L96.jacobian","text":"jacobian(x::Vector{Float64}, t::Float64, dx_params::ParamDict) \n\nComputes the Jacobian of Lorenz-96 about the state x. The time variable t is a dummy\nvariable for consistency with integration methods, dx_params is a parameter dictionary\nwhich is called for the forcing parameter. Note that this is designed to load entries in\na zeros array and return a sparse array to make a compromise between memory\nand computational resources.\n\n\n\n\n\n","category":"method"},{"location":"models/L96/#DataAssimilationBenchmarks.L96.l96s_tay2_step!-Tuple{Vector{Float64}, Float64, Dict{String, Any}}","page":"L96","title":"DataAssimilationBenchmarks.L96.l96s_tay2_step!","text":"l96s_tay2_step!(x::Vector{Float64}, t::Float64, kwargs::Dict{String,Any}) \n\nOne step of integration rule for l96 second order taylor rule\nThe ρ and α are to be computed by the auxiliary functions in the L96 submodule, depending\nonly on p, and supplied for all steps. This is the general formulation which includes,\neg. dependence on the truncation of terms in the auxilliary function C with\nrespect to the parameter p.  In general, truncation at p=1 is all that is\nnecessary for order 2.0 convergence, and in this case C below is identically\nequal to zero.  This auxilliary function can be removed (and is removed) in other\nimplementations for simplicity.\n\nThis method is derived in\nGrudzien, C. et al.: On the numerical integration of the Lorenz-96 model,\nwith scalar additive noise, for benchmark twin experiments,\nGeosci. Model Dev., 13, 1903–1924, https://doi.org/10.5194/gmd-13-1903-2020, 2020.\nNOTE: this Julia version still pending validation as in the above manuscript\n\n\n\n\n\n","category":"method"},{"location":"models/IEEE39bus/#IEEE39-Bus-Swing-Equation-Model","page":"IEEE39bus","title":"IEEE39 Bus Swing Equation Model","text":"","category":"section"},{"location":"models/IEEE39bus/","page":"IEEE39bus","title":"IEEE39bus","text":"Modules = [DataAssimilationBenchmarks.IEEE39bus]","category":"page"},{"location":"models/IEEE39bus/#DataAssimilationBenchmarks.IEEE39bus.dx_dt-Tuple{Union{SubArray{Float64, 1}, Vector{Float64}}, Float64, Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}}","page":"IEEE39bus","title":"DataAssimilationBenchmarks.IEEE39bus.dx_dt","text":"dx_dt(x::VecA, t::Float64, dx_params::ParamDict) \n\nTime derivative of the phase and fequency of the effective-network swing equation model.\nInput x is a 2 n_g vector of the phase and fequency at each of the n_g generator buses.\nThe input dx_params is a ParamDict of all system parameters to be passed to the\nintegration scheme.  The system is currenty defined autonomously to be run as an SDE,\nnoise perturbed steady state.\n\n\n\n\n\n","category":"method"},{"location":"experiments/FilterExps/#FilterExps","page":"FilterExperiments","title":"FilterExps","text":"","category":"section"},{"location":"experiments/FilterExps/","page":"FilterExperiments","title":"FilterExperiments","text":"Modules = [DataAssimilationBenchmarks.FilterExps]","category":"page"},{"location":"experiments/FilterExps/#DataAssimilationBenchmarks.FilterExps.filter_param-Tuple{Tuple{String, String, Int64, Int64, Float64, Int64, Float64, Float64, Float64, Int64, Float64, Float64}}","page":"FilterExperiments","title":"DataAssimilationBenchmarks.FilterExps.filter_param","text":"filter_param(args::Tuple{String,String,Int64,Int64,Float64,Int64,Float64,Float64, \n                         Float64,Int64,Float64,Float64})\n\nFilter joint state-parameter estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size etc. are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"experiments/FilterExps/#DataAssimilationBenchmarks.FilterExps.filter_state-Tuple{Tuple{String, String, Int64, Int64, Float64, Int64, Float64, Int64, Float64}}","page":"FilterExperiments","title":"DataAssimilationBenchmarks.FilterExps.filter_state","text":"filter_state(args::Tuple{String,String,Int64,Int64,Float64,Int64,Float64, \n                         Int64,Float64})\n\nFilter state estimation twin experiment.  Twin experiment parameters such as the observation dimension, observation uncertainty, data assimilation method, number of cycles, ensemble size  etc. are specified in the arguments.\n\n\n\n\n\n","category":"method"},{"location":"#DataAssimilationBenchmarks.jl","page":"Home","title":"DataAssimilationBenchmarks.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DataAssimilationBenchmarks.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"methods/EnsembleKalmanSchemes/#Ensemble-Kalman-Schemes","page":"EnsembleKalmanSchemes","title":"Ensemble Kalman Schemes","text":"","category":"section"},{"location":"methods/EnsembleKalmanSchemes/","page":"EnsembleKalmanSchemes","title":"EnsembleKalmanSchemes","text":"Modules = [DataAssimilationBenchmarks.EnsembleKalmanSchemes]","category":"page"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ArView","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ArView","text":"ArView = Union{Array{Float64, 2}, SubArray{Float64, 2}}\n\nType union of arrays and views of arrays for use within ensemble conditioning operations, integration schemes and other array operations.\n\n\n\n\n\n","category":"type"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ConM","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ConM","text":"ConM = Union{UniformScaling{Float64}, Symmetric{Float64}}\n\nType union of conditioning matrix types, which will be used for optimization routines in the transform method.\n\n\n\n\n\n","category":"type"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.CovM","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.CovM","text":"CovM = Union{UniformScaling{Float64}, Diagonal{Float64}, Symmetric{Float64}}\n\nType union of covariance matrix types, for optimized computation based on characteristics.\n\n\n\n\n\n","category":"type"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.TransM","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.TransM","text":"TransM = Union{Tuple{Symmetric{Float64,Array{Float64,2}},Array{Float64,2},Array{Float64,2}},\n               Tuple{Symmetric{Float64,Array{Float64,2}},Array{Float64,1},Array{Float64,2}},\n               Array{Float64,2}}\n\nType union of right transform types, including soley a transform, or a transform, weights and rotation package.\n\n\n\n\n\n","category":"type"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.VecA","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.VecA","text":"VecA = Union{Vector{Float64}, SubArray{Float64, 1}}\n\nType union of vectors and ensemble members of sample for using in integration schemes and related array operations.\n\n\n\n\n\n","category":"type"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator-Tuple{Matrix{Float64}, Int64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.alternating_obs_operator","text":"alternating_obs_operator(ens::Array{Float64,2}, obs_dim::Int64, \n                         kwargs::Dict{String,Any})\n\nObservation of alternating state vector components, possibly nonlinear transformation. This selects components to observe based on the observation dimension and if parameter estimation is being performed.  Parameters are always unobservable, and even states will be removed from the state vector until the observation dimension is appropriate.  Nonlinear observations are optional, as described for the Lorenz-96 model by Asch, Bocquet, Nodet pg. 181.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens","text":"analyze_ens(ens::ArView, truth::Vector{Float64})\n\nComputes the ensemble RMSE as compared with truth twin, and the ensemble spread.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para-Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, Vector{Float64}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.analyze_ens_para","text":"analyze_ens_para(ens::ArView, truth::Vector{Float64})\n\nComputes the ensemble RMSE as compared with truth twin, and the ensemble spread.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!-Union{Tuple{T1}, Tuple{Union{SubArray{Float64, 2}, Matrix{Float64}}, T1}} where T1<:Union{Tuple{Symmetric{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}}, Tuple{Symmetric{Float64, Matrix{Float64}}, Vector{Float64}, Matrix{Float64}}, Matrix{Float64}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ens_update!","text":"ens_update!(ens::ArView, transform::T1) where {T1 <: TransM}\n\nUpdates ensemble by right-transform method. In the case where this follows the stochastic EnKF as in Carrassi et al. 2018, this simply performs right mutliplication.  All other cases use the 3-tuple including the right transform for the anomalies, the weights for the mean and the random, mean-preserving orthogonal matrix.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V<:AbstractVector{Float64}, Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ensemble_filter","text":"ensemble_filter(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},  \n                obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})\n\nGeneral filter analysis step, wrapping the transform / update, and inflation steps. Optional keyword argument includes state_dim for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!-Tuple{Matrix{Float64}, Float64, Int64, Int64}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_param!","text":"inflate_param!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, \n               state_dim::Int64)\n\nParameter variable multiplicative covariance inflation. State variables are assumed to be in the leading rows, while extended state, parameter variables are after. Multiplicative inflation is performed only in the trailing components.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!-Tuple{Matrix{Float64}, Float64, Int64, Int64}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.inflate_state!","text":"inflate_state!(ens::Array{Float64,2}, inflation::Float64, sys_dim::Int64, \n               state_dim::Int64)\n\nDynamic state variable multiplicative covariance inflation.  State variables are assumed to be in the leading rows, while extended state variables, parameter variables are after. Multiplicative inflation is performed only in the leading components.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V<:AbstractVector{Float64}, Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_classic","text":"ls_smoother_classic(analysis::String, ens::Array{Float64,2}, obs::Array{Float64,2},  \n                    obs_cov::CovM, state_infl::Float64, kwargs::Dict{String,Any})\n\nLag-shift ensemble kalman smoother analysis step, classical version. Classic enks uses the last filtered state for the forecast, different from the  iterative schemes which use the once or multiple-times re-analized posterior for the initial condition for the forecast of the states to the next shift.\n\nOptional argument includes state dimension for extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V<:AbstractVector{Float64}, Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_gauss_newton","text":"ls_smoother_gauss_newton(analysis::String, ens::Array{Float64,2},                   \n                         obs::Array{Float64,2}, obs_cov::CovM, state_infl::Float64,\n                         kwargs::Dict{String,Any}; ϵ::Float64=0.0001,\n                         tol::Float64=0.001, max_iter::Int64=5)\n\nLag-shift Gauss-Newton IEnKS analysis step, algorithm 4, Bocquet & Sakov 2014 ienks uses the final re-analyzed posterior initial state for the forecast,  which is pushed forward in time from the initial conidtion to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration-Tuple{String, Matrix{Float64}, Matrix{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V<:AbstractVector{Float64}, Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Float64, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.ls_smoother_single_iteration","text":"ls_smoother_single_iteration(analysis::String, ens::Array{Float64,2},       \n                             obs::Array{Float64,2}, obs_cov::CovM,\n                             state_infl::Float64, kwargs::Dict{String,Any})\n\nLag-shift ensemble kalman smoother analysis step, single iteration version. Single-iteration enks uses the final re-analyzed posterior initial state for the forecast, which is pushed forward in time to shift-number of observation times. Optional argument includes state dimension for an extended state including parameters. In this case, a value for the parameter covariance inflation should be included in addition to the state covariance inflation.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth-Tuple{Int64}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.rand_orth","text":"rand_orth(N_ens::Int64)\n\nThis generates a random. mean preserving, orthogonal matrix as in Sakov & Oke 2008.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root-Tuple{T} where T<:Union{UniformScaling{Float64}, Diagonal{Float64, V} where V<:AbstractVector{Float64}, Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root","text":"square_root(M::T) where {T <: CovM}\n\nAuxiliary function for computing the square roots of multiple types of covariance matrices, with the subroutines defined according to the sub-type.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv-Tuple{T} where T<:Union{UniformScaling{Float64}, Diagonal{Float64, V} where V<:AbstractVector{Float64}, Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.square_root_inv","text":"square_root_inv(M::T) where {T <: CovM}\n\nAuxiliary function for computing the square root inverse of multiple types of covariance matrices, with the subroutines defined according to the sub-type. This will optionally return a computation of the inverse and the square root itself all as a byproduct of the singular value decomposition computation.\n\n\n\n\n\n","category":"method"},{"location":"methods/EnsembleKalmanSchemes/#DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform-Tuple{String, Matrix{Float64}, Vector{Float64}, Union{UniformScaling{Float64}, Diagonal{Float64, V} where V<:AbstractVector{Float64}, Symmetric{Float64, S} where S<:(AbstractMatrix{<:Float64})}, Dict{String, Any}}","page":"EnsembleKalmanSchemes","title":"DataAssimilationBenchmarks.EnsembleKalmanSchemes.transform","text":"transform(analysis::String, ens::Array{Float64,2}, obs::Vector{Float64},        \n       obs_cov::CovM, kwargs::Dict{String,Any}; conditioning::ConM=1000.0I, \n       m_err::Array{Float64,2}=(1.0 ./ zeros(1,1)),\n       tol::Float64 = 0.0001,\n       j_max::Int64=40,\n       Q::CovM=1.0I)\n\nComputes transform and related values for various flavors of ensemble Kalman schemes. Serves as an auxilliary function for EnKF, ETKF(-N), EnKS, ETKS(-N), IEnKS(-N), where \"analysis\" is a string which determines the type of transform update.  The observation error covariance should be of UniformScaling, Diagonal or Symmetric type.\n\n\n\n\n\n","category":"method"}]
}
