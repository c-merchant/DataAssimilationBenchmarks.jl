        - ##############################################################################################
        - module FilterExps
        - ##############################################################################################
        - ##############################################################################################
        - # imports and exports
        - using JLD2
        - using Random, Distributions, Statistics
        - using LinearAlgebra
        - using ..EnsembleKalmanSchemes, ..DeSolvers, ..L96, ..IEEE39bus
        - export filter_state, filter_param
        - 
        - ##############################################################################################
        - ##############################################################################################
        - # Type union declarations for multiple dispatch
        - 
        - # dictionaries of parameters
        - ParamDict = Union{Dict{String, Array{Float64}}, Dict{String, Vector{Float64}}}
        - 
        - ##############################################################################################
        - ##############################################################################################
        - # Main filtering experiments, debugged and validated for use with schemes in methods directory
        - ##############################################################################################
        - 
        2 function filter_state(args::Tuple{String,String,Int64,Int64,Float64,Int64,Float64,
        -                                   Int64,Float64})
        - 
        -     # time the experiment
        2     t1 = time()
        - 
        -     # Define experiment parameters
        2     time_series, method, seed, nanl, obs_un, obs_dim, γ, N_ens, infl = args
        - 
        -     # load the timeseries and associated parameters
        2     ts = load(time_series)::Dict{String,Any}
        2     diffusion = ts["diffusion"]::Float64
        2     dx_params = ts["dx_params"]::ParamDict
        2     tanl = ts["tanl"]::Float64
        2     model = ts["model"]::String
        2     h = 0.01
        -     
        -     # define the dynamical model derivative for this experiment from the name
        -     # supplied in the time series
        2     if model == "L96"
        1         dx_dt = L96.dx_dt
        1     elseif model == "IEEE39bus"
        1         dx_dt = IEEE39bus.dx_dt
        -     end
        -     
        -     # define integration method
        2     step_model! = rk4_step!
        -     
        -     # number of discrete forecast steps
        2     f_steps = convert(Int64, tanl / h)
        - 
        -     # set seed 
        2     Random.seed!(seed)
        -     
        -     # define the initialization
        2     obs = ts["obs"]::Array{Float64, 2}
        2     init = obs[:, 1]
        2     sys_dim = length(init)
        2     ens = rand(MvNormal(init, I), N_ens)
        - 
        -     # define the observation range and truth reference solution
        2     obs = obs[:, 2:nanl + 1]
        2     truth = copy(obs)
        - 
        -     # define kwargs for the filtering method
        -     # and the underlying dynamical model
        2     kwargs = Dict{String,Any}(
        -                               "dx_dt" => dx_dt,
        -                               "f_steps" => f_steps,
        -                               "step_model" => step_model!, 
        -                               "dx_params" => dx_params,
        -                               "h" => h,
        -                               "diffusion" => diffusion,
        -                               "gamma" => γ,
        -                              )
        - 
        -     # define the observation operator, observation error covariance and observations
        -     # with error observation covariance operator taken as a uniform scaling by default,
        -     # can be changed in the definition below
        2     obs = alternating_obs_operator(obs, obs_dim, kwargs)
        2     obs += obs_un * rand(Normal(), size(obs))
        2     obs_cov = obs_un^2.0 * I
        -     
        -     # check if there is a diffusion structure matrix
        2     if haskey(ts, "diff_mat")
        1         kwargs["diff_mat"] = ts["diff_mat"]
        -     end
        -    
        -     # create storage for the forecast and analysis statistics
        2     fore_rmse = Vector{Float64}(undef, nanl)
        2     filt_rmse = Vector{Float64}(undef, nanl)
        -     
        2     fore_spread = Vector{Float64}(undef, nanl)
        2     filt_spread = Vector{Float64}(undef, nanl)
        - 
        -     # loop over the number of observation-forecast-analysis cycles
        4     for i in 1:nanl
        -         # for each ensemble member
    14000         for j in 1:N_ens
        -             # loop over the integration steps between observations
   294000             @views for k in 1:f_steps
   441000                 step_model!(ens[:, j], 0.0, kwargs)
   441000                 if model == "IEEE39bus"
        -                     # set phase angles mod 2pi
   213500                     ens[1:10, j] .= rem2pi.(ens[1:10, j], RoundNearest)
        -                 end
        -             end
        -         end
        - 
        -         # compute the forecast statistics
     7000         fore_rmse[i], fore_spread[i] = analyze_ens(ens, truth[:, i])
        - 
        -         # after the forecast step, perform assimilation of the observation
     7000         analysis = ensemble_filter(method, ens, obs[:, i], obs_cov, infl, kwargs)
     7000         ens = analysis["ens"]
        - 
        -         # compute the analysis statistics
    13998         filt_rmse[i], filt_spread[i] = analyze_ens(ens, truth[:, i])
        -     end
        - 
        2     data = Dict{String,Any}(
        -                             "fore_rmse" => fore_rmse,
        -                             "filt_rmse" => filt_rmse,
        -                             "fore_spread" => fore_spread,
        -                             "filt_spread" => filt_spread,
        -                             "method" => method,
        -                             "seed" => seed, 
        -                             "diffusion" => diffusion,
        -                             "dx_params" => dx_params,
        -                             "sys_dim" => sys_dim,
        -                             "obs_dim" => obs_dim, 
        -                             "obs_un" => obs_un,
        -                             "gamma" => γ,
        -                             "nanl" => nanl,
        -                             "tanl" => tanl,
        -                             "h" =>  h,
        -                             "N_ens" => N_ens, 
        -                             "state_infl" => round(infl, digits=2)
        -                            ) 
        -     
        2     if haskey(ts, "diff_mat")
        1         data["diff_mat"] = ts["diff_mat"]
        -     end
        -         
        2     path = joinpath(@__DIR__, "../data/", method * "/") 
        2     name = method * 
        -             "_" * model *
        -             "_state_seed_" * lpad(seed, 4, "0") * 
        -             "_diff_" * rpad(diffusion, 5, "0") * 
        -             "_sysD_" * lpad(sys_dim, 2, "0") * 
        -             "_obsD_" * lpad(obs_dim, 2, "0") * 
        -             "_obsU_" * rpad(obs_un, 4, "0") *
        -             "_gamma_" * lpad(γ, 5, "0") *
        -             "_nanl_" * lpad(nanl, 5, "0") * 
        -             "_tanl_" * rpad(tanl, 4, "0") * 
        -             "_h_" * rpad(h, 4, "0") *
        -             "_nens_" * lpad(N_ens, 3,"0") * 
        -             "_stateInfl_" * rpad(round(infl, digits=2), 4, "0") * 
        -             ".jld2"
        - 
        2     save(path * name, data)
        2     print("Runtime " * string(round((time() - t1)  / 60.0, digits=4))  * " minutes\n")
        - end
        - 
        - 
        - ##############################################################################################
        - 
        - 
        1 function filter_param(args::Tuple{String,String,Int64,Int64,Float64,Int64,Float64,Float64,
        -                                   Float64,Int64,Float64,Float64})
        -     # time the experiment
        1     t1 = time()
        - 
        -     # Define experiment parameters
        1     time_series, method, seed, nanl, obs_un, obs_dim, γ, param_err, param_wlk, N_ens, 
        -     state_infl, param_infl = args
        - 
        -     # load the timeseries and associated parameters
        1     ts = load(time_series)::Dict{String,Any}
        1     diffusion = ts["diffusion"]::Float64
        1     dx_params = ts["dx_params"]::ParamDict
        1     tanl = ts["tanl"]::Float64
        1     model = ts["model"]::String
        1     h = 0.01
        -     
        -     # define the dynamical model derivative for this experiment from the name
        -     # supplied in the time series
        1     if model == "L96"
        1         dx_dt = L96.dx_dt
        0     elseif model == "IEEE39bus"
        0         dx_dt = IEEE39bus.dx_dt
        -     end
        1     step_model! = rk4_step!
        -     
        -     # number of discrete forecast steps
        1     f_steps = convert(Int64, tanl / h)
        - 
        -     # set seed 
        1     Random.seed!(seed)
        -     
        -     # define the initialization
        1     obs = ts["obs"]::Array{Float64, 2}
        1     init = obs[:, 1]
        1     if model == "L96"
        1         param_truth = pop!(dx_params, "F")
        0     elseif model == "IEEE39bus"
        0         param_truth = [pop!(dx_params, "H"); pop!(dx_params, "D")]
        0         param_truth = param_truth[:]
        -     end
        - 
        -     # define state and extended system dimensions
        1     state_dim = length(init)
        1     sys_dim = state_dim + length(param_truth)
        - 
        -     # define the initial ensemble
        1     ens = rand(MvNormal(init, I), N_ens)
        -     
        -     # extend this by the parameter ensemble    
        -     # note here the covariance is supplied such that the standard deviation is a percent
        -     # of the parameter value
        1     param_ens = rand(MvNormal(param_truth[:], diagm(param_truth[:] * param_err).^2.0), N_ens)
        -     
        -     # define the extended state ensemble
        1     ens = [ens; param_ens]
        - 
        -     # define the observation range and truth reference solution
        1     obs = obs[:, 2:nanl + 1]
        1     truth = copy(obs)
        -     
        -     # define kwargs, note the possible exclusion of dx_params if it is the only parameter for
        -     # dx_dt and this is the parameter to be estimated
        1     kwargs = Dict{String,Any}(
        -                               "dx_dt" => dx_dt,
        -                               "dx_params" => dx_params,
        -                               "f_steps" => f_steps,
        -                               "step_model" => step_model!,
        -                               "h" => h,
        -                               "diffusion" => diffusion,
        -                               "gamma" => γ,
        -                               "state_dim" => state_dim,
        -                               "param_infl" => param_infl
        -                              )
        -     
        -     # define the observation operator, observation error covariance and observations with
        -     # error observation covariance operator currently taken as a uniform scaling by default,
        -     # can be changed in the definition below
        1     obs = alternating_obs_operator(obs, obs_dim, kwargs)
        1     obs += obs_un * rand(Normal(), size(obs))
        1     obs_cov = obs_un^2.0 * I
        -     
        -     # we define the parameter sample as the key name and index
        -     # of the extended state vector pair, to be loaded in the
        -     # ensemble integration step
        1     if model == "L96"
        1         param_sample = Dict("F" => [41:41])
        0     elseif model == "IEEE39bus"
        0         param_sample = Dict("H" => [21:30], "D" => [31:40])
        -     end
        1     kwargs["param_sample"] = param_sample
        - 
        -     # create storage for the forecast and analysis statistics
        1     fore_rmse = Vector{Float64}(undef, nanl)
        1     filt_rmse = Vector{Float64}(undef, nanl)
        1     para_rmse = Vector{Float64}(undef, nanl)
        -     
        1     fore_spread = Vector{Float64}(undef, nanl)
        1     filt_spread = Vector{Float64}(undef, nanl)
        1     para_spread = Vector{Float64}(undef, nanl)
        - 
        -     # loop over the number of observation-forecast-analysis cycles
        2     for i in 1:nanl
        -         # for each ensemble member
     7000         for j in 1:N_ens
    73500             if  model == "IEEE39bus"
        -                 # we define the diffusion structure matrix with respect to the sample value
        -                 # of the inertia, as per each ensemble member
        0                 diff_mat = zeros(20,20)
        0                 diff_mat[LinearAlgebra.diagind(diff_mat)[11:end]] = 
        -                 dx_params["ω"][1] ./ (2.0 * ens[21:30, j])
        -                 
        0                 kwargs["diff_mat"] = diff_mat
        -             end
   147000             @views for k in 1:f_steps
        -                 # loop over the integration steps between observations
   367500                 step_model!(ens[:, j], 0.0, kwargs)
   367500                 if model == "IEEE39bus"
        -                     # set phase angles mod 2pi
    70000                     ens[1:10, j] .= rem2pi.(ens[1:10, j], RoundNearest)
        -                 end
        -             end
        -         end
        -     
        -         # compute the forecast statistics
     3500         fore_rmse[i], fore_spread[i] = analyze_ens(ens[1:state_dim, :], truth[:, i])
        - 
        -         # after the forecast step, perform assimilation of the observation
     3500         analysis = ensemble_filter(method, ens, obs[:, i], obs_cov, state_infl, kwargs)
     3500         ens = analysis["ens"]::Array{Float64,2}
        - 
        -         # extract the parameter ensemble for later usage
     3500         param_ens = @view ens[state_dim+1:end, :]
        - 
        -         # compute the analysis statistics
     3500         filt_rmse[i], filt_spread[i] = analyze_ens(ens[1:state_dim, :], truth[:, i])
     3500         para_rmse[i], para_spread[i] = analyze_ens_para(param_ens, param_truth)
        - 
        -         # include random walk for the ensemble of parameters
        -         # with standard deviation given by the param_wlk scaling
        -         # of the mean vector
     3500         param_mean = mean(param_ens, dims=2)
     6999         param_ens .= param_ens + param_wlk * param_mean .* rand(Normal(),
        -                                                                 length(param_truth), N_ens)
        -     end
        - 
        1     data = Dict{String,Any}(
        -                             "fore_rmse" => fore_rmse,
        -                             "filt_rmse" => filt_rmse,
        -                             "param_rmse" => para_rmse,
        -                             "fore_spread" => fore_spread,
        -                             "filt_spread" => filt_spread,
        -                             "param_spread" => para_spread,
        -                             "method" => method,
        -                             "seed" => seed, 
        -                             "diffusion" => diffusion,
        -                             "dx_params" => dx_params,
        -                             "param_truth" => param_truth,
        -                             "sys_dim" => sys_dim,
        -                             "state_dim" => state_dim,
        -                             "obs_dim" => obs_dim, 
        -                             "obs_un" => obs_un,
        -                             "gamma" => γ,
        -                             "param_err" => param_err,
        -                             "param_wlk" => param_wlk,
        -                             "nanl" => nanl,
        -                             "tanl" => tanl,
        -                             "h" => h,
        -                             "N_ens" => N_ens, 
        -                             "state_infl" => round(state_infl, digits=2),
        -                             "param_infl" => round(param_infl, digits=2)
        -                            )
        -     
        -     # check if there is a diffusion structure matrix
        1     if haskey(ts, "diff_mat")
        0         data["diff_mat"] = ts["diff_mat"]
        -     end
        - 
        1     path = joinpath(@__DIR__, "../data/", method * "/") 
        1     name =  method * 
        -             "_" * model *
        -             "_param_seed_" * lpad(seed, 4, "0") * 
        -             "_diff_" * rpad(diffusion, 5, "0") * 
        -             "_sysD_" * lpad(sys_dim, 2, "0") * 
        -             "_stateD_" * lpad(state_dim, 2, "0") * 
        -             "_obsD_" * lpad(obs_dim, 2, "0") * 
        -             "_obsU_" * rpad(obs_un, 4, "0") * 
        -             "_gamma_" * lpad(γ, 5, "0") * 
        -             "_paramE_" * rpad(param_err, 4, "0") * 
        -             "_paramW_" * rpad(param_wlk, 6, "0") * 
        -             "_nanl_" * lpad(nanl, 5, "0") * 
        -             "_tanl_" * rpad(tanl, 4, "0") * 
        -             "_h_" * rpad(h, 4, "0") * 
        -             "_nens_" * lpad(N_ens, 3, "0") * 
        -             "_stateInfl_" * rpad(round(state_infl, digits=2), 4, "0") *
        -             "_paramInfl_" * rpad(round(param_infl, digits=2), 4, "0") * 
        -             ".jld2"
        - 
        1     save(path * name, data)
        1     print("Runtime " * string(round((time() - t1)  / 60.0, digits=4))  * " minutes\n")
        - end
        - 
        - 
        - ##############################################################################################
        - # end module
        - 
        - end
        - 
